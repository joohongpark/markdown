# 5. 프로세스/스레드 간 동기화 문제

프로세스나 스레드 간 동일한 자원을 공유하거나 정보를 공유하며 협업해야 할 일이 생길 것이다. 프로세스의 경우는 IPC를 이용하면 되고 스레드는 전역변수 등 서로 공유하는 메모리 영역을 통해 공유하면 될 것이다. 하지만 이런 경우 거의 필연적으로 동기화 관련 문제들이 생긴다. 발생할 수 있는 문제들에 대해 알아보자.

## 경쟁 상태 (Race Condition)

하나의 자원을 여러 개의 프로세스나 스레드가 접근할 때 발생할 수 있는 문제이다. 동시에 접근을 하여도 접근의 타이밍이나 순서가 미세하게 차이가 날 수 있다. 이런 경우에 대해 경쟁 상태라고 한다. 또 이를 발생시키는 코드 구역을 임계 구역이라고 한다.

### 경쟁 상태의 예제와 임계 구역(critical section)

만약에 한 스레드에선 변수를 100회 증가, 다른 스레드에서는 변수를 100회 감소시키는 로직이 들어있으며 두 스레드는 하나의 변수에 대해 접근한다고 가정해보자.

그리고 그 변수의 초기값은 0이며 두 스레드는 거의 동시에 생성된다고 가정해보자. 두 스레드가 종료되면 변수 내에는 0이 저장될 것으로 예상되고 실제로 실행해보면 0이 저장된 것을 볼 수 있다.

하지만 프로그램을 여러 번 실행해보면 항상 0이 나오진 않는 것을 확인할 수 있다. 그 이유는 로직 상에서 해당 변수(메모리)에 직접 접근하여 증가 혹은 감소시킨 것이 아니라 그 변수 내의 값을 레지스터로 인출한 다음 증가 혹은 감소시킨 후 메모리에 다시 저장하기 때문이다.

이게 무슨 문제가 되냐면, 초기값 변수가 0일 때 증가 스레드가 동작해 '0' 이란 값을 레지스터로 인출하는 도중 context switch가 발생해 감소 스레드가 실행된다 가정해보자. 그러면 감소 스레드가 동작하는데 운좋게 해당 변수에 접근하여 증가시키는 동안 context switch가 발생하지 않았다고 고려해보자. 그러면 그 변수는 '-1' 이 될 것이다. 하지만 이 상황에서 다시 context switch가 발생해 증가 스레드가 동작한다면 이미 '0' 이란 값을 인출했으니 이 값에 그대로 1을 더해 다시 해당 변수(메모리)에 저장하여 변수는 '1' 이 될 것이다.

여기서 중요하게 보아야 할 부분은 위에서 변수에 접근(메모리에 접근) 하여 레지스터에 저장하여 1 증가 후 다시 변수에 값을 저장(메모리에 저장) 하는 부분이다. 예상하지 않은 동작, 즉 경쟁 상태는 코드의 이 부분에서 발생한 것이다. 이런 코드의 부분을 **임계 구역 (critical section)** 이라고 한다.

## 임계 구역 (Critical Section)

위 둘 이상의 스레드나 프로세스에서 하나의 자원에 접근하게 될 때 각각 자원에 대해 접근을 이상하게 하게 되는 경우가 있을 수 있다. 접근을 하면 안 되는 순간에 접근을 하거나 동시에 접근하는 경우이다. 그런 우려가 있는 코드 구역을 임계 구역이라고 한다.

### 입장 구역, 임계 구역, 퇴장 구역

#### entry section (입장 구역)

임계 구역에 돌입하기 바로 직전의 코드를 의미한다.

#### critical section (임계 구역)

둘 이상의 스레드에서 실행되면 안되는 공간을 의미한다.

#### exit section (퇴장 구역)

임계 구역을 빠져나간 구간을 의미한다.

#### remainder section (나머지 구역)

나머지 구역을 통틀어서 의미한다.

## 임계 구역에 대한 처리

임계 구역에 대해 다음 세 가지 처리가 되어야 문제가 발생하지 않는다.

### 상호 배제 (Mutual Exclusion / Mutex)

상호 배제는 공유하지 못하는 자원을 여러 스레드나 프로세스가 동시에 사용하지 못하도록 하는 기법이다.

### 진행 (Progress) 혹은 교착 방지 (avoid Deadlock)

상호 배제를 한다고 아무 프로세스나 스레드가 접근을 못하고 있으면 안된다. 서로가 자원만을 기다리고 있으면 아무런 진행을 못하고 있게 된다. 이를 교착/데드락이라고 하며 이런 상황에 빠지게 되면 안된다.

### 한정 대기 (Bounded Waiting) 혹은 기아 방지 (avoid Starvation)

자원을 기다리는 프로세스가 계속 기다리고만 있으면 안된다. 계속 자원만을 기다리고 있는 프로세스나 스레드에 대해 기아 상태에 빠졌다고 한다. 이런 상황을 방지하여야 한다.

## 임계 구역에 대한 해결법

임계 구역에서 발생할 수 있는 문제를 해결할 수 있는 방안들이 있다. 크게 HW적인 방법과 SW적인 방법으로 나눌 수 있다.

### HW적인 방법

#### Memory Barrier

- 컴파일러나 CPU가 명령어의 순서를 최적화하기 위해 맘대로 바꾸는 경우가 있다. 이런 경우 임계 영역에 대해 컴파일러나 CPU가 명령어 순서를 마음대로 바꾸지 못하게 x86 cpu에서는 관련 명령어를 지원한다. (참조 : [https://ko.wikipedia.org/wiki/메모리_배리어](https://ko.wikipedia.org/wiki/메모리_배리어))
- 하지만 이런 경우 모든 임계 영역에 대해 커버할 수는 없다. 단순히 순서만 중요한 부분에 대해 적용한다.

#### Atomic Operation (원자적 연산)

- 더이상 쪼갤 수 없어 간섭 자체를 받지 못하는 연산을 원자적 연산이라고 한다.
- 하드웨어 단에서 명령어 등을 이용하여 원자적 연산을 수행하면 중간에 연산 내용이 임의로 변경되지 않는다.
- 상호 배제를 적용하기 위해 사용할 수 있다.
- compare_and_swap / test_and_set 연산 (함수)이 널리 사용된다.

#### 인터럽트 방지 (싱글코어일 경우)

- 어차피 연산은 하나의 코어에서 일어나기 때문에 임계 구역에서 인터럽트를 방지해두면 된다. 하지만 최근 컴퓨터 환경에서는 멀티코어이기 때문에 이런 방법은 소용이 없다.

### SW적인 방법 (예전 방법)

#### Dekker's algorithm (데커 알고리즘)

- 두 개의 스레드에서 상호 배제를 방지한다.

#### Peterson’s Algorithm (피터슨 알고리즘)

- 두 개 혹은 그 이상의 스레드에서 상호 배제를 방지한다.

## Spin Lock

### Busy Waiting (바쁜 대기) 혹은 Spinning

경쟁 상태를 해결하기 위한 SW 알고리즘은 임계 구역에 진입하기 전 while문으로 임계 구역에 들어가도 되는지 들어갈때가지 확인한다. 이렇게 자원을 소모하는 비교문과 반복문을 이용해서 대기하는 것을 Busy Waiting (바쁜 대기) 이라고 한다.

### Spin Lock (스핀락)

임계 구역 진입 전까지 바쁜 대기 (Spinning)를 하고 있는 것으로 상호 배제를 해결하는 것을 스핀락이라고 한다.

비록 임계 구역 진입때까지 무의미한 비교문과 반복문을 수행하지만 특정 상황에 대해 장점이 있다.

- 만약 문맥 전환 (context switch)를 하는 데 비용(시간)이 많이 들 경우와 기다리는 시간이 짧을 경우
  - 임계 구역에 진입했는데 진입이 불가능할 경우 다른 프로세스로 문맥 전환을 하는 것 보다 프로세스에 할당된 시간까지 기다리고 문맥 전환을 하는 것이 더 유용하다.
- 구현이 간단하다.

스핀락에 정 반대로 대응되는 적절한 용어가 없는 것으로 알고 있다. (있을수도 있음.)

## 임계 구역에 대한 (보다 고급스러운) 해결법

보통 특수한 경우 외엔 위에 제시된 방법을 직접 사용하지 않고 아래 3가지 방법을 사용한다. 또 이 해결법들은 상호 배제만 해결해 주기 때문에 데드락과 기아상태가 발생할 수 있다.

### (Mutex) Lock

- 임계 구역에 진입할 때 (입장 구역) 다른 스레드에서 lock이 걸렸는지 확인한다. 만약에 걸려있으면 Lock이 풀릴 때 까지 기다린다. Lock이 풀리면 그 때 진입한다. 임계 구역을 실행하고 빠져 나갈 때 (최장 구역) Lock을 해제한다.
- 장점은 구현하기도 쉽고 생각하기도 쉬운 상황이다. 하지만 임계영역을 사용하는 스레드가 여러개라고 하여도 뮤텍스락을 사용하면 임계영역은 하나만 들어갈 수 있다. 이런 상황에서 어느 한 임계영역이 계속 자원을 소비하고 있으면 어떨까? 3인 가구가 하나의 화장실을 이용하고 있는데 한 명이 화장실에서 안나오면 미칠 노릇일 것이다. 또 서로가 서로의 자원을 기다리는 상황이 발생할 수 있다. (이를 데드락이라 한다.)
- 또 임계 구역을 하나만 사용하게 할 때에만 사용한다.

### Semaphore

- 세마포어는 (철도의) 신호기라는 뜻을 가지고 있다. 어원이 되는 세마포어는 철도 길이 교차가 되서 기차 통행을 통제해야 하는 신호기일 것이다.
- 여기서의 세마포어는 철도가 임계 구역에 해당되고 열차가 프로세스나 스레드에 해당되어 세마포어가 임계 구역을 실행해도 되는지, 실행하면 안되는지 알려준다.
- 바이너리 세마포어와 카운팅 세마포어가 있다. 바이너리 세마포어는 0/1만의 값을 가지기 때문에 (뮤텍스) 락과 동일하게 동작된다. 카운팅 세마포어는 여러 값을 가질 수 있어 여러 상황에 대해 제어가 가능하다. 예를 들어 3인 가구인데 화장실이 두개일 경우 화장실의 사용 중인 개수를 세마포어에 저장해 현재 사용 가능한 화장실의 개수를 카운팅하는 개념으로 효율적으로 사용하게 할 수 있다.
- 위에서 사용한 뮤텍스 락은 하나의 프로세스 내에서밖에 사용을 못하지만 세마포어는 여러 프로세스들이 공유하며 사용하게 할 수 있다.

### Monitor

- 세마포어보다 더 발전된 형태의 동기화 해결 도구이다. 모니터는 일종의 추상적 자료 구조이며 자바에는 언어 차원에서 구현되어 있다. 비교적 고급 언어에서 모니터에 해당되는 도구/키워드를 제공해 준다.
- 큐와 공유자원 등으로 이루어져 있으며 배타동기와 조건동기를 위한 큐를 두고 결과적으로 임계구역을 하나의 스레드에서 접근하도록 해준다.
- 세마포어처럼 다루기 복잡하지 않다.