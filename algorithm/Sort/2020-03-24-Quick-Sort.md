# Quick Sort (퀵 정렬)

## 1. 퀵 정렬이란?

- 정렬 알고리즘 중 일반적으로 사용되는 알고리즘
- 평균적인 정렬 속도가 매우 빠름 (합병 정렬과 동일하거나 더 빠른 퍼포먼스를 보임). 하지만 최악의 정렬상태에 대해선 속도가 매우 느려짐.
- 임의의 한 점 (pivot)을 기준으로 그 점보다 작은 원소와 큰 원소로 나눈 후 작은 원소들, 큰 원소들에 대해서도 동일하게 재귀적으로 나누어 정렬한다.

## 2. 퀵 정렬의 단계별 순서 및 예제

```
[5, 2, 7, 8, 3, 6, 1, 4] 와 같은 배열이 있다.
해당 배열에서 pivot으로 사용될 원소를 임의로 고른다.
이후 분할 작업을 실시해야 하는데 여기서 분할하는 알고리즘엔 주로 두 가지 방법이 있다.

먼저 Lomuto partition scheme (로무토 분할 계획)을 이용해서 분할하는 과정은 다음과 같다.
보통 배열의 마지막 원소를 pivot으로 고르며 가장 첫번째 원소부터 pivot 이전 원소까지 부터 비교를 수행한다.
비교 루프 수행 중 i번째 원소가 pivot보다 작다면 가장 첫번째 원소와 해당 원소를 swap 하는데, 이후 i보다 큰 순번의 원소가 pivot보다 작은 상황이 발생하면 가장 첫번째 원소는 swap 되었으므로 그 다음 원소와 해당 원소를 swap 한다.
해당과 같이 반복하면 결국 좌편에는 pivot보다 작은 원소만 쌓이게 되며 현재 pivot는 우측에 있으므로 좌측부터 swap 해 나간 원소의 다음 원소와 swap 하면 결과적으로 swap 양 옆에는 swap보다 작은 원소 혹은 큰 원소만 쌓이게 된다.
이를 시각적으로 나타내면 다음과 같다.
[5, 2, 7, 8, 3, 6, 1, (4)] // pivot 지정
[(5), 2, 7, 8, 3, 6, 1, (4)] // 4와 5를 비교하면 5가 크므로 swap 하지 않는다. (해당 구간에서는 swap 해도 원본과 대상이 동일하므로 의미가 없다. 따라서 알고리즘 구현 시 제외하여도 된다.)
[(2), (5), 7, 8, 3, 6, 1, (4)] // 4와 2를 비교하면 2가 작으므로 swap 한다.
[(2), 5, (7), 8, 3, 6, 1, (4)] // 4와 7를 비교하면 7이 크므로 swap 하지 않는다.
[(2), 5, 7, (8), 3, 6, 1, (4)] // 4와 8를 비교하면 8이 크므로 swap 하지 않는다.
[2, (3), 7, 8, (5), 6, 1, (4)] // 4와 3를 비교하면 3이 작으므로 swap 한다.
[2, (3), 7, 8, 5, (6), 1, (4)] // 4와 6를 비교하면 6이 크므로 swap 하지 않는다.
[2, 3, (1), 8, 5, 6, (7), (4)] // 4와 3를 비교하면 3이 작으므로 swap 한다.
[2, 3, 1, (4), 5, 6, 7, (8)] // 마지막으로 pivot 값과 다음 swap 대상 값을 swap 하면 분할이 끝난다. pivot 왼쪽에는 작은 값, pivot 오른쪽에는 큰 값이 있는 것을 볼 수 있다.

Hoare partition scheme (호어 분할 계획)을 이용해서 분할하는 과정은 다음과 같다.
보통 배열의 중간에 위치한 원소를 pivot으로 고르며 pivot에 대해 비교 원소를 두개 잡고 증가시켜 가며 swap 해 나가는 방식인데, 원소를 양 끝에 있는 원소를 잡는다.
가장 왼쪽에 있는 원소를 최소값, 가장 오른쪽에 있는 원소를 쵀댓값으로 잡는다 하자. 각각의 원소가 pivot 값보다 크거나 작으면 swap 시키는 방식이다. 이후 양 끝에 있는 원소가 중간 지점을 향해 나아가는 방식이다.
이를 시각적으로 나타내면 다음과 같다.
[(5), 2, 7, (8), 3, 6, 1, (4)] // pivot(8), 최댓값(오른쪽), 최솟값(왼쪽) 지정. 오른쪽은 pivot보다 작아야 하며 왼쪽은 pivot 보다 커야 함. 먼저 왼쪽 (혹은 오른쪽) 부터 pivot 보다 큰 값이 나올 때 까지 loop를 수행한다.
[(5), 2, 7, 8, 3, 6, 1, 4] // 5는 8보다 작으므로 다음 비교대상으로 넘김
[5, (2), 7, 8, 3, 6, 1, 4] // 2는 8보다 작으므로 다음 비교대상으로 넘김
[5, 2, (7), 8, 3, 6, 1, 4] // 7는 8보다 작으므로 다음 비교대상으로 넘김
[5, 2, 7, (8), 3, 6, 1, 4] // 8은 8보다 작지 않으므로 swap 필요
[5, 2, 7, (8), 3, 6, 1, (4)] // 4는 8보다 작으므로 swap 필요
[5, 2, 7, (4), 3, 6, 1, (8)] // swap
[5, 2, 7, 4, (3), 6, 1, (8)] // 3은 8보다 작으므로 다음 비교대상으로 넘김
[5, 2, 7, 4, 3, (6), 1, (8)] // 6은 8보다 작으므로 다음 비교대상으로 넘김
[5, 2, 7, 4, 3, 6, (1), (8)] // 1은 8보다 작으므로 다음 비교대상으로 넘김
[5, 2, 7, 4, 3, 6, 1, (4)] // 8은 8보다 작지 않으므로 swap 필요. 가리키는 두 대상이 같으므로 loop 종료하며 이 경우엔 pivot 위치가 8번째가 된다.

이후 pivot에 의해 분할된 최댓값 배열, 최솟값 배열에 대해 재귀적으로 위 작업을 재 실행한다.

```

## 3. 알고리즘

- $N$ 개의 원소를 가진 $[a_1, a_2, ... , a_{N-1}, a_N]$ 의 배열이 주어지면 해당 원소 중 pivot을 정한 후 적절한 알고리즘 (위에서 예시로 든 호어 혹은 로무토)을 사용해 분할 작업을 수행한다.

- 분할 작업이 끝나면 pivot을 제외한 부분 배열에 대해 위 분할 작업을 재 실행한다.

- Lomuto 분할법에 대한 Pseudo code (의사 코드)

  ```
  lomuto(배열, 배열 시작점 위치, 배열 끝점 위치)
  {
  	pivot = 배열[배열 끝점 위치]
  	i = 최솟값 위치
  	for(j가 0부터 배열 끝점 위치까지 loop)
  	{
  		만약 배열[j] < pivot 일 경우
  			배열[j]와 배열[i]의 값을 변경하고 i에 1을 더한다.
  	}
  	배열[i]와 배열[배열 끝점 위치]의 값 변경
  }
  ```
  - Pivot의 선택은 반드시 배열의 끝점 위치를 택할 필요는 없다.
  - 특정 상황에서 Lomuto 분할법이 Hoare 코드보다 비효율적으로 동작된다.

- Hoare 분할법에 대한 Pseudo code (의사 코드)

  ```
  hoare(배열, 배열 시작점 위치, 배열 끝점 위치)
  {
  	pivot = 배열[배열 중간 위치]
  	start = 배열 시작점 위치 + 1
  	stop = 배열 끝점 위치 - 1
  	while(start가 stop보다 작을 때)
  	{
  		배열[start] 값이 pivot 보다 큰 값이 나올 때까지 start 값을 해당 라인에서 계속 증가시킴
  		배열[stop] 값이 pivot 보다 작은 값이 나올 때까지 stop 값을 해당 라인에서 계속 감소시킴
  		start가 stop보다 작을 때 해당 반복구문 탈출
  		배열[start]와 배열[stop]의 값을 변경
  	}
  	stop : pivot의 위치를 의미함.
  }
  ```

  - 마찬가지로 Pivot의 선택은 반드시 배열의 중간 위치를 택할 필요는 없다.

## 4. 시간 복잡도

- Best-case performance : $O(N log_2N)$ 혹은 $O(N)$
- Average performance : $O(N log_2N)$
- Worst-case performance : $O(n^2)$

## 5. 코드 구현

- C 코드로 구현 (Hoare partition schame 사용, 위 구현과 약간 다름)

```c
void quick_sort(int arr[], int len)
{
    int i = 1;
  	int j = len - 1;
    int tmp;
  	int pivot = arr[0];
    if(len > 1) // 해당 함수는 재귀적으로 호출되기 때문에 len 값이 1보다 클 때에만 해당 구문 시행
    {
        while(i <= j) // 종료 조건
        {
            if( (arr[i] >= pivot) && (arr[j] <= pivot) )
            {
                tmp = arr[j];
                arr[j] = arr[i];
                arr[i] = tmp;
            }
            if(arr[i] <= pivot)
            {
                i++;
            }
            if(arr[j] > pivot)
            {
                j--;
            }
        }
        tmp = arr[0];
        arr[0] = arr[j];
        arr[j] = tmp;
        if( i > 1 )
        {
            quick_sort(arr, i - 1);
        }
        if( (len - i) > 0 )
        {
            quick_sort(arr + i, (len - i));
        }
    }
}
```

