# Selection Sort (선택 정렬)

## 1. 선택 정렬이란?

- 주어진 배열 중 최솟값 혹은 최댓값을 선택하여 순서대로 나열하는 방식이다.
- 실제 최솟값과 위치해야 할 장소를 swap 하여 나열을 수행한다.

## 2. 선택 정의 단계별 순서 및 예제

​	오름차 순 정렬 예제

```
[3, 2, 1, 4] 와 같은 배열이 있다.
주어진 4개의 원소 크기만큼 Iterative 하게 최솟값을 수동으로 찾아낸다.
[(3), (2), (1), (4)]
찾아 보면 최솟값은 1이 되며 가장 왼쪽의 원소와 위치를 swap 한다.
[(3), 2, (1), 4] -> [(1), 2, (3), 4]
해당 작업을 수행하면 가장 왼쪽에 위치한 원소는 최솟값이 된다.

이제 원소 1을 제외한 다른 원소로부터 최솟값을 찾아낸다.
[1, (2), (3), (4)]
2가 최솟값이고 기존에 찾아낸 최솟값의 원소의 오른쪽에 위치하므로 별도로 swap 작업을 진행하지 않는다.

이제 원소 1, 2을 제외한 다른 원소로부터 최솟값을 찾아낸다.
[1, 2, (3), (4)]
최솟값은 3이 되며 위와 같은 사유로 별도로 swap 작업을 진행하지 않는다.
```

## 3. 알고리즘 (오름차 기준)

- $N$ 개의 원소를 가진 배열이 주어질 때 $i = 1$ 을 시작으로 $a_1$ 부터 $a_N$ 까지 최솟값을 찾아낸다.
- $a_j$가 최솟값이라면 $a_i$ 와 $a_j$ 의 위치를 swap 한다.
- $i = i + 1$ 을 수행하며, $i = N - 1$ 이 될 때까지 위 작업을 반복 수행한다.

## 4. Loop 횟수 및 시간 복잡도

- N개의 원소가 존재 시 정렬 루프를 $ (N-1)+(N-2)+\cdots + 2+1=\frac{N(N-1)}{2} = \frac{1}{2}N^2 - \frac{1}{2}N$ 번 돌게 된다.
- 해당 알고리즘의 시간 복잡도는 Big-O 표기법에 따라 $O(n^2)$ 로 표기된다.
- 주어진 배열의 정렬 상태에 따라 Loop 횟수가 변하지 않는다. (Best case, Worst case, Average Perfomance가 동일하다.)

## 5. 코드 구현

- C 코드로 구현

```c
//200320 jhpark
void selection_sort(int a[], int size)
{
    int tmp;
    int min_offset;
    for (int i = 0; i < size; i++) {
        min_offset = i;
        for (int j = i; j < size; j++) {
            if(a[min_offset] > a[j])
            {
                min_offset = j;
            }
        }
        tmp = a[i];
        a[i] = a[min_offset];
        a[min_offset] = tmp;
    }
}
```



