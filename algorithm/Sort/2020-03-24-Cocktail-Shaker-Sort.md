#Cocktail Shaker Sort (칵테일 정렬)

## 1. 칵테일 정렬이란?

- 양방향 버블 정렬 등 여러 비슷한 이름이 있으며 거품 정렬의 단점을 개선한 정렬 알고리즘이다.
- 거품 정렬이 최대/최소 값을 향해서 해당 방향으로만 정렬하는 방식이라면 해당 정렬은 최댓값, 최솟값이 배열 가장자리에 위치하여 왕복하며 정렬하는 구조이다. 정렬되는 동작이 칵테일 쉐이커를 흔드는 것과 비슷하여 칵테일 알고리즘이란 이름이 붙었다.
- 왕복하여 정렬 작업을 실핼할 때 정렬 동작이 발생하지 않으면 정렬을 중단한다.

## 2. 칵테일 정렬의 단계별 순서 및 예제

​	오름차 순 정렬 예제

```
[3, 2, 1, 4] 와 같은 배열이 있다.
가장 첫번째 원소 3과 앞 원소 2를 비교한다.
[(3), (2), 1, 4] 
2보다 3이 더 크므로 원소의 위치를 다음과 같이 바꾼다.
[3, 2, 1, 4] -> [2, 3, 1, 4]
그 다음 원소 3과 앞 원소 2를 비교한다.
[2, (3), (1), 4]
1보다 3이 더 크므로 원소의 위치를 다음과 같이 바꾼다.
[2, 3, 1, 4] -> [2, 1, 3, 4]
그 다음 원소 3과 앞 원소 4를 비교한다.
[2, 1, (3), (4)]
3보다 4가 더 크므로 위치를 변경하지 않는다.
해당 단계에서 가장 우측에 위치한 값은 정렬이 완료되었으므로 우측 원소를 제외한 후 좌측으로 정렬 작업을 수행한다.

[2, 1, 3, 4]
3, 1의 대소를 비교한다
[2, (1), (3), 4]
1보다 3이 크므로 위치를 변경하지 않는다.
[2, 1, 3, 4] -> [2, 1, 3, 4]
그 다음 2, 1의 대소를 비교한다.
[(2), (1), 3, 4]
2보다 1이 크므로 위치를 변경한다.
[2, 1, 3, 4] -> [1, 2, 3, 4]

정렬이 완료되었으므로 정렬 작업을 중단한다.
```

## 3. 알고리즘 (오름차 기준)

- $N$ 개의 원소를 가진 배열이 주어질 때 $i = 1$ 을 시작으로 $a_i$ 와 $a_{i+1}$ 의 대소 관계를 비교한다.
- 대소 관계를 비교하여 오름차 순서에 맞게 해당 원소를 swap 한다. $a_i > a_{i+1}$  가 되면 두 원소를 swap 한다.
- $i = i + 1$ 수행하며, $i = N-1$ 이 될 때까지 반복한다.
- $a_N$ 은 오름차 기준으로 주어진 배열에서 최댓값이 된다. 이제 $a_N$ 을 제외하고 역 방향으로 정렬 작업을 수행한다.
- 대소 관계를 비교하여 오름차 순서에 맞게 해당 원소를 swap 한다. 만일 오름차 순으로 정렬할 때라면 $a_i < a_{i-1}$  가 되면 두 원소를 swap 한다.
- $i = i - 1$ 수행하며, $i = 1$ 이 될 때까지 반복한다.
- $a_1$ 은 오름차 기준으로 주어진 배열에서 최솟값이 된다. 이제 $a_N, a_1$ 을 제외하고 $a_{N-1}, a_2$ 부터 정렬 작업을 수행한다. 또는 왕복 정렬을 수행한 동안 swap 동작이 발생하지 않았다면 해당 배열은 정렬된 배열이므로 정렬 작업을 중단한다.

## 4. Loop 횟수 및 시간 복잡도

- N개의 원소가 존재 시, Best Case를 제외하고 정렬 루프를 $ (N-1)+(N-2)+\cdots + 2+1=\frac{N(N-1)}{2} = \frac{1}{2}N^2 - \frac{1}{2}N$ 번 돌게 된다. 이는 거품 정렬과 유사하다.
- 따라서 Worst Case, Average Case는 해당 알고리즘의 시간 복잡도는 Big-O 표기법에 따라 $O(n^2)$ 로 표기된다.
- 하지만 Best Case에서는 $ (N-1) $ 만큼 돌게 되어 해당 케이스에서의 시간 복잡도는 Big-O 표기법에 따라 $O(n)$ 로 표기된다.

## 5. 코드 구현

​	C 코드로 구현

```c
//20200315 jhpark
void cocktail_sort(int arr[], int arr_size)
{
    int tmp;
    int min = 0, max = arr_size - 1;
    char sorted = 0;
    while(min != max)
    {
        // Min -> Max Sort
        sorted = 1;
        for (int i = min; i < max; i++)
        {
            if(arr[i] > arr[i+1])
            {
                tmp = arr[i+1];
                arr[i+1] = arr[i];
                arr[i] = tmp;
                sorted = 0;
            }
        }
        if(sorted)
        {
            break;
        }
        max--;
        // Max -> Min Sort
        sorted = 1;
        for (int i = max; i > min; i--)
        {
            if(arr[i] < arr[i-1])
            {
                tmp = arr[i-1];
                arr[i-1] = arr[i];
                arr[i] = tmp;
                sorted = 0;
            }
        }
        if(sorted)
        {
            break;
        }
        min++;
    }
}
```

