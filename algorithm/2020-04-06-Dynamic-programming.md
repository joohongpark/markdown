# Recursion 과 Dynamic Programming

recursion이란 한국어로 반복, 되풀이를 위미한다. 프로그래밍에서 recursion이란 특정 코드 내에서 자기 자신을 참조하는 것을 의미한다. 이러한 방식(함수 내부에서 자기 자신을 호출하는 로직이 있는 함수)이 적용된 함수를 재귀 함수(Recursion Function)라 부른다.

프로그래밍에서 재귀 함수가 사용되는 예시는 매우 다양한데 점화식으로 구현되는 관계식을 함수로 구현될 때, 혹은 커다란 문제를 분할하여 해결할 때(Devide and Conquer / 분할 정복), 또는 최단 경로를 찾을 때 주로 사용된다. 재귀 함수를 설명할 때 가장 흔히 사용되는 피보나치 수열을 이용해 설명하겠다.

피보나치 수열은 초기값과 점화식으로 정의되는 수열이며 정의는 다음과 같다.

> $f(0) = 0$
>
> $f(1) = 1$
>
> $f(n) = f(n-1) + f(n-2)$

여기서 f(x)를 C 함수로 구현해보자.

> ```c
> int fibonacci(int n) {
>   if(n == 0) {
>        return 0;
>     } else if (n == 1) {
>         return 1;
>     }
>     else {
>          return fibonacci(n-1) + fibonacci(n-2);
>      }
>   }
>   ```

함수의 정의에 따라 입력값에 따라 다른 값을 반환하다. 인수가 0 혹은 1일 경우 상수값을 return 해 주며, 2부터는 함수 본인을 재귀적으로 호출한다. 해당 함수의 실행 과정을 나타내면 다음과 같다.

> 예를 들어 fibonacci(4)를 실행한다면
>
> ```
> fibonacci(4) // #1
> ├─ fibonacci(3) // #2
> │   ├─fibonacci(2) // #3
> │   │   ├─fibonacci(1) = 1 // #4
> │   │   └─fibonacci(0) = 0 // #5
> │   └─fibonacci(1) = 1 // #6
> └─ fibonacci(2) // #7
>     ├─fibonacci(1) = 1 // #8
>     └─fibonacci(0) = 0 // #9
> ```
>
> 위와 같이 실행될 것이다.

위 구조를 살펴보면 의도한 대로 동작하는 것을 알 수 있지만 동시에 불필요한 연산(동일한 인수의 함수 콜)을 여러번 수행하는 것을 볼 수 있다. 예를 들어 n = 2인 함수는 두번 호출되었으며 이는 불필요한 재귀 연산이 발생하였다고 볼 수 있을 것이다.

또 해당 연산 수행 시 내부 함수 콜스택에 함수가 계속 쌓이게 되는 결과가 발생한다. 따라서 일반적인 데스크탑 컴퓨터 환경 기준으로 n = 100 만 되도 불필요한 함수 콜이 엄청나게 많이 발생하고 스택에 중복된 함수가 쌓이게 되어 콜스택이 오버플로우 되어 정상적인 실행 결과를 얻기 힘들게 된다.

함수 콜스택에 계속 쌓이는 이유는 해당 함수의 재귀함수 return을 할 때 그 값을 확정짓고 종료되야 해당 함수가 종료되어 콜스택에서 pop 된다. 하지만 return을 하기 위해 또 다른 함수를 호출하므로 재귀 구문이 종료될 때 까지 해당 함수는 종료되지 않고 스택에 계속 쌓이게 된다.

해당 문제점은 다이나믹 프로그래밍 기법을 이용해 연산 횟수를 크게 줄일 수 있다.

**다이나믹 프로그래밍**은 **문제를 작은 문제로 분할해서 풀 때 동일한 작은 문제가 여러번 사용되면 그 문제의 값을 저장하여 다른 구문에서 문제의 값을 찾을 때 저장된 값을 반환해 불필요한 연산을 줄이는 방법론**을 의미한다.

다이나믹 프로그래밍이란 단어 자체는 컴퓨터 공학에서 유래된 단어가 아니며 이 단어를 고안한 리처드 벨만이라는 수학자는 단어 자체에 별 뜻 없이 지었다고 한다. 따라서 다이나믹 프로그래밍의 **프로그래밍** 이라는 단어는 프로그래머가 하는 프로그래밍이 아니라 문제를 해결하기 위한 **플래닝**에 더 가까운 의미이다.

따라서 우리말로 다이나믹 프로그래밍이란 단어보다 동적 계획법이 더 적합한 표현일 것이며 용어보다는 해당 방법론이 지니는 의미에 더 집중해야 한다.

다이나믹 프로그래밍엔 **메모이제이션(Memoization, 메모아이제이션)** 이라는 개념이 있다. 위에서 말한 작은 문제를 저장하는 것을 메모이제이션이라 한다. 또 문제를 Top-Down 방식으로 접근하거나 Bottom-Up 방식으로 접근하거나에 따라 이전 값을 저장하는 용어가 바뀐다. Top-Down 접근은 문제를 위에서부터 작은 단위로 찾아가는 과정 중 값을 필요할 때에만 연산하고 저장하여 다시 그 값을 찾을 떄 연산하지 않고 저장되는 값을 반환한다. 이를 메모이제이션이라 하고 Bottom-Up 접근은 문제를 작은 단위로 나누어 아래에서부터 위로 값에 수렴해가는 과정을 말한다. 여기서는 타뷸레이션(Tabulation) 이라고 부른다. (하지만 대체로 보통 뭉뚱그려 메모이제이션이라 부른다. 용어는 크게 중요하지 않다. 다이나믹 프로그래밍의 특성이 중요하다.)

동적 계획법을 사용하면 위 연산은 다음과 같이 줄어든다.

> 예를 들어 fibonacci(4)를 동적 계획법(Top-Down)을 이용해 실행한다면
>
> ```
> fibonacci(4) // #1 (Memoization)
> ├─ fibonacci(3) // #2 (Memoization)
> │   ├─fibonacci(2) // #3 (Memoization)
> │   │   ├─fibonacci(1) = 1 // #4 (Memoization)
> │   │   └─fibonacci(0) = 0 // #5 (Memoization)
> │   └─fibonacci(1) = 1 // #6 (위에서 n = 1일때 값을 구했으므로 값 반환.)
> └─ fibonacci(2) // #7 (위에서 n = 2일때 값을 구했으므로 값 반환.)
> ```
>
> 위와 같이 실행될 것이다. N이 증가할 수록 위 단순 재귀호출을 이용한 함수보다 연산이 줄어듬을 체감할 수 있다.
>
> Bottom-Up 방식은 fibonacci(4)를 fibonacci(0)부터 접근한다.
>
> ```
> fibonacci(0) // 0
> fibonacci(1) // 1
> fibonacci(2) // fibonacci(0) + fibonacci(1) = 0 + 1 = 1
> fibonacci(3) // fibonacci(1) + fibonacci(2) = 1 + 1 = 2
> fibonacci(4) // fibonacci(2) + fibonacci(3) = 1 + 2 = 3
> // 중단
> ```
>
> 가장 작은 문제부터 규칙에 따라 상향식으로 접근한다. 만약 N=4가 될 경우 중단한다.

위 Top-Down 방법으로 접근한 동적 계획법을 C 함수로 구현한 것은 다음과 같다.

> ```c
> int fib_memo[20] = {0, };
> int fibonacci_memo(int n) {
>   if(n == 0) {
>     return 0;
>   } else if (n == 1) {
>     return 1;
>   } else {
>     if (fib_memo[n] == 0) {
>       fib_memo[n] = fibonacci_memo(n-1) + fibonacci_memo(n-2);
>     }
>     return fib_memo[n];
>   }
> }
> ```
>
> 기존 코드를 다음과 같이 수정하여 하면 이미 구한 피보나치 값을 다시 구하지 않게 된다. 이 방법은 N이 0이 될 때까지 문제를 분할하여 접근하므로 탑다운 방식이며 접근 도중 N보다 작은 피보나치 수가 중복으로 필요한 상황이 있으므로 피보나치 수열을 별도 배열에 메모이제이션 하며 다른 재귀 함수에서 필요로 할 때 메모이제이션 한 배열에 접근한다.

피보나치 수열을 동적 계획법으로 풀 때에는 효율성이나 코드 가독성 면에서 Bottom-Up 방법이 더 낫다. 예시는 다음과 같다.

> ```c
> int fibonacci_bott(int n) {
>   int fib[20] = {0, 1, 0};
>   for (int i = 2; i <= n; i++)
>   {
>     fib[i] = fib[i-1] + fib[i-2];
>   }
>   return fib[n];
> }
> ```
>
> 피보나치 수열을 0부터 주어진 숫자까지 재귀를 사용하지 않고 구한다. (이를 보통 Tabulation이라고 한다.) 다음과 같이 구현하면 추가적인 함수 콜이 없으므로 탑다운 동적계획법보다 더 효율적이다.
>
> 위 코드는 배열의 크기가 고정되어 있으므로 N이 커지면 잘못된 포인터 값을 가리키게 될 수도 있다. 이를 개선한 코드는 다음과 같다.
>
> ```c
> unsigned long fibonacci_iter(int n) {
>  int answer = 0;
>  unsigned long fib[3] = {0, 1, 0};
>  for (int i = 1; i < n; i++)
>  {
>      fib[(i+1)%3] = fib[(i+2)%3] + fib[i%3];
>  }
>  answer = fib[n % 3];
>  return answer;
> }
> ```
>
> 배열을 순환적으로 대입하고 참조되도록 구현된 예제이다. 하지만 다음과 같이 구현하면 배열을 순환시키는 로직이 추가되므로 속도상 불리할수도 있으며 배열 인덱스를 계산하는데 다소 복잡하다.

위의 여러 예제들을 보면 동적 계획법의 접근법에는 여러 방법이 있음을 알 수 있다. 주어진 문제와 환경에 따라 적합한 방법을 택하는 것이 중요하다.

