# Merge Sort (합병 정렬)

## 1. 합병 정렬이란?

- 폰 노이만이 고안한 정렬 알고리즘이다.
- *****분할 정복 알고리즘(Divide and Conquer algorithm)에 속한다.
- 정렬할 리스트를 재귀적으로 절반씩 분할하여 문제를 작은 크기로 나눈다. (Divide) 이후 작게 잘려진 문제들에 대해 정렬 작업을 수행하며 작은 문제의 해를 하나로 다시 합친다. 이 작업을 나눈 문제를 합칠 때까지 재귀적으로 실행한다. (Conquer / Merge)
- 데이터의 분산(Best/Worst Case)에 대해 영향을 받지 않는다.
- 데이터 정렬 과정에서 신규 배열이 필요하므로 정렬 중 메모리에 대한 추가 할당이 필요하다.

## 2. 선택 정의 단계별 순서 및 예제

```
[8, 6, 7, 5, 3, 4, 1, 2] 와 같은 배열이 있다.
이 배열을 반으로 분할한다.
[8, 6, 7, 5] [3, 4, 1, 2]
이 배열들은 아직 정렬하기엔 너무 크다. 배열을 각각 반으로 분리한다.
[8, 6] [7, 5] [3, 4] [1, 2]
이 배열들은 아직 정렬하기엔 너무 크다. 배열을 각각 반으로 분리한다.
[8] [6] [7] [5] [3] [4] [1] [2]
이제 분리된 배열들을 병합하며 해결을 수행한다.
좌측 2개 쌍부터 정렬 작업을 수행한다. (각각의 1개 크기의 요소를 2개 크기의 배열에 삽입한다.)
[8] [6] [7] [5] [3] [4] [1] [2] => [6, 8] [5, 7] [3, 4] [1, 2]
병합된 2개의 각각의 원소의 배열 작업은 완료되었다. 또다시 좌측 2개 쌍부터 정렬 작업을 수행한다.
해당 과정의 상세는 다음과 같다.
[6, 8] [5, 7] => [ ,  ,  ,  ] // 크기가 2인 배열의 한 쌍을 합치는 것이므로 4개 크기의 배열을 준비함.
[6, 8] [ , 7] => [5,  ,  ,  ] // 6과 5를 비교하여 크기가 작은 원소부터 삽입한다.
[ , 8] [ , 7] => [5, 6,  ,  ] // 6과 7를 비교하여 크기가 작은 원소부터 삽입한다.
[ , 8] [ ,  ] => [5, 6, 7,  ] // 8과 7를 비교하여 크기가 작은 원소부터 삽입한다.
[ ,  ] [ ,  ] => [5, 6, 7, 8] // 우측 배열엔 원소가 없고 좌측 배열은 정렬이 완료되었으므로 그대로 이어 붙인다.
이 작업을 각각에 대해 진행하면 다음과 같다.
[8, 6] [5, 7] [3, 4] [1, 2] => [5, 6, 7, 8] [1, 2, 3, 4]
작업을 한번 더 시행하여 기존 배열과 크기가 동일하게 Merge 되면 정렬 작업은 끝나게 된다.
[5, 6, 7, 8] [1, 2, 3, 4] => [1, 2, 3, 4, 5, 6, 7, 8]
```

## 3. 알고리즘

- $N$ 개의 원소를 가진 $[a_1, a_2, ... , a_{N-1}, a_N]$ 의 배열이 주어지면 이를 반으로 분할한다.
- 반으로 분할된 배열은 정렬되어 있지 않으므로 다시 반으로 분할한다.
- 계속 진행하면 $[a_1],[a_2],[...],[a_{N-1}],[a_N]$ 형태인 배열이 되는데, 이를 분할한 것의 역순으로 정렬 및 병합을 수행한다.
- 정렬 및 병합 작업은 다음과 같이 수행한다. 다음과 같은 배열 $[a_i, a_{i+1}, ... , a_{X-1}, a_X]$ ,  $[a_j, a_{j+1}, ... , a_{Y-1}, a_Y]$ 의 병합을 수행한다면 먼저 가장 최솟값인 $a_i$ 와 $a_j$ 를 비교하여 새 배열에 집어 넣는다. 이후 다음 최솟값끼리 비교하여 계속 집어 넣으며 둘 중 한 배열의 원소가 모두 비게 되면 나머지 배열을 새 배열에 그대로 집어 넣는다.

## 4. Loop 횟수 및 시간 복잡도

- N개의 원소의 배열을 반으로 분할(Divide)하는 데 $log_2(N)$ 만큼의 Loop를 돌게 된다.
- 이후 배열을 정렬하는 동안 $2N$만큼의 Loop를 돌게 된다.
- 따라서 Big-O 표기법으로 나타내면 $O(Nlog_2(N))$ 이 된다. 이는 모든 케이스에서 동일하다.

## 5. 코드 구현

- C 코드로 구현 (Top-down implementation)

```c
//20200317 jhpark
#include <stdio.h>

#define SIZE 10
int tmp[SIZE];
void merge(int a[], int a_size, int b[], int b_size, int tmp[])
{
    int a_p = 0;
    int b_p = 0;
    int t_p = 0;
    while( (a_size != a_p) && (b_size != b_p) )
    {
        if(a[a_p] < b[b_p])
        {
            tmp[t_p] = a[a_p];
            a_p++;
        }
        else
        {
            tmp[t_p] = b[b_p];
            b_p++;
        }
        t_p++;
    }
    while( (a_size != a_p) || (b_size != b_p) )
    {
        if(a_size != a_p)
        {
            tmp[t_p] = a[a_p];
            a_p++;
        }
        else if(b_size != b_p)
        {
            tmp[t_p] = b[b_p];
            b_p++;
        }
        t_p++;
    }
    for (int i = 0; i < t_p; ++i)
    {
        a[i] = tmp[i];
    }
}
void divide(int a[], int len)
{
    int h = len / 2;
    if(len > 1)
    {
        divide(a, h);
        divide(a + h, len - h);
        merge(a, h, a + h, len - h, tmp);
    }
}
int main()
{
    int test1[SIZE] = {1, 3, 5, 2, 6, 7, 9, 8, 4, 10};
    divide(test1, SIZE);
    return 0;
}


```



