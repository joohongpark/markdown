# Java의 클래스와 인스턴스, 상속

자바에서는 객체란 개념이 존재한다. 객체는 개체들이 시스템 안에 각각 따로 노는것이 아닌 특정한 규칙으로 그룹화한 것으로 객체 내에 개체들이 존재한다.

예를 들면 자동차나 사람은 각각 Object라 볼 수 있다. 자동차가 도로를 달리는거나 사람이 밥을 먹는 행위 등은 Entity라 볼 수 있다.

자동차는 자동차 공장에서 설계도를 이용해서 동일한 제품을 제작한다. 자바에서 클래스와 인스턴스의 개념에 대입하면 설계도는 클래스가 되고 인스턴스는 자동차가 된다.

자바에서 객체 지향 프로그래밍을 처음 접할 때 Object/Class/Instance 용어 간 차이와 관계에 대해서 헷갈리게 되는데 간단하게 요약하면 다음과 같다.

### 객체 (Object)

객체는 그것의 상태(state)와 행동(behavior) (각각 내부 변수와 함수 - 메소드를 의미한다.)이 정의되어 있는 코드의 묶음을 의미한다. 현실에서도 객체는 상태와 행동을 가지고 있다. 예를 들면 자동차의 상태는 시동 여부, 기어비, 차량 번호 등이 존재하며 행동은 기어 밟기, 기어 변속하기, 시동걸기 등이 존재한다. 자바 프로그래밍에서 상태는 필드 (클래스 내부 변수)로 나타내며 행동은 메소드 (클래스 내부 함수)로 부른다.

하지만 클래스는 객체가 아니다. 클래스는 단순히 객체의 설계도를 의미하기 때문이다. 자동차 설계도나 빵 레시피를 자동차나 빵이라고 부르지 않는 것처럼.

### 클래스 (Class)

클래스는 객체를 생성할 때 그 객체의 설계도 혹은 프로토타입을 의미한다. 위에서 말한 객체의 상태나 행동을 클래스를 이용하여 정의한다. 자바에서 생성할 객체가 어떤 형태를 가지고 어떤 기능을 가질지 클래스를 이용하여 정의한다.

필드(field)와 메소드(method)를 이용하여 클래스를 정의하는데 정의한다는 말은 현실 세계에서 설계도를 제작하는 것과 같다고 볼 수 있다.

### 인스턴스 (Instance)

인스턴스는 클래스(설계도)로부터 생성된 고유한 객체를 의미한다. 예를 들어 실제 세계에서 동일한 설계도를 이용해 제품을 제작한다 해도 그 제품의 사용자의 성향이나 제조사의 성향에 따라 다른 제품이 나온다. 같은 클래스로 만들었지만 결국 각각의 객체로써 존재하는 것이다.

신규 인스턴스가 생성될 때 마다 그 인스턴스를 위한 공간을 클래스로부터 생성하여 메모리에 신규로 할당하여 준다.

### 상속 (Inheritance)

자바에서는 상속이란 개념이 존재하는데 위에서 클래스가 설계도에 대응되는 개념이라고 했다. 실제 세계에서도 자동차를 설계할 때 기존 자동차의 엔진이나 프레임을 가지고 설계 변경하여 자동차를 만든다. 빵을 굽거나 요리를 할때도 마찬가지이다. 기존 레시피를 수정하는 식으로 요리를 한다. 왜냐하면 처음부터 만들기에는 시간과 비용이 많이 소모되기 때문이다.

자바에서도 상속을 이용하여 클래스를 선언하는 것을 지원한다. 예를 들어 기존에 덧셈과 뺄셈만을 지원하는 계산기를 클래스를 이용하여 선언하였다 가정하고 이후로 사칙연산 전부를 지원하는 계산기를 만든다고 하면 기존 계산기에 곱셈과 나눗셈만 추가하면 될 것이다.

상속 관계에 있는 클래스는 Superclass와 Subclass가 있다. Superclass는 상속을 해 주는 클래스로 베이스 클래스, 부모 클래스로도 불린다. Subclass는 상속을 받는 클래스로 확장 클래스, 자식 클래스로도 불린다.

참고로 자바에서 사용되는 모든 클래스는 Object라는 클래스를 상속받아 사용한다. 따라서 Object 클래스는 다른 모든 클래스에 대해 Superclass이며 다른 모든 클래스는 Subclass이다.

## 1. 클래스 선언 및 사용

자바 클래스의 단순한 사용 예제와 객체 변수 사용 예제이다.

```java
public class Main
{
	public static void main(String[] args) {
        // 클래스 타입 자료형의 객체 변수 선언 및 초기화
		calc c1 = new calc();
		calc c2 = new calc();
        
        // 클래스 타입 자료형의 객체 변수를 선언하여 다른 객체를 대입할 때
		calc c3;
		c3 = c1;
        
        // 프리미티브 자료형도 Wrapper Class를 이용해 사용할 수 있다.
        Integer i = new Integer(10);
        
		c1.x = 10;
		c1.y = 20;
		c1.add();
		c2.x = 100;
		c2.y = 200;
		c2.add();
		System.out.println(c1.result);
		System.out.println(c2.result);
		System.out.println(c3.result);
	}
}

class calc {
	int x, y, result;
	void add() {
		result = this.x + this.y;
	}
}
```

calc라는 덧셈을 해주는 클래스를 이용해 new 연산자로 calc 클래스로부터 인스턴스를 생성하여 c1, c2 객체 변수에 할당하였다. c3은 선언만 수행한 후 기존 c1을 대입하였다.

기본적으로 c1, c2, c3의 객체 변수는 실제로 그 객체를 가지고 있는 것이 아니다. 메모리에 new 연산자를 이용하여 할당된 위치를 가리키는 것이다. 따라서 c3 = c1 과 같은 코드를 수행할 때에는 새롭게 메모리를 할당하여 c1의 내용을 통째로 복사하는 것이 아니라 c1이 가리키고 있는 위치를 c3에도 대입하는 것일 뿐이다.

c1과 c2는 같은 클래스로 만들었지만 본질적으로 다른 인스턴스이다. c1과 c3은 변수 이름이 다르지만 본질적으로 같은 인스턴스이다. 따라서 연산 결과를 보면 c1과 c3이 같으며 c2가 다름을 확인할 수 있다.

Wrapper Class를 이용해 정수형 인스턴스를 생성한 i는 10이라는 값을 가지고 있는 인스턴스이다. 따라서 기존 프리미티브 자료형으로 선언한 변수는 단순히 숫자이지만 i는 객체이다. 따라서 보다 더 확장된 기능을 사용할 수 있다.

## 2. 간단한 상속 예제

다른 클래스로부터 상속을 받기 위해 extend라는 키워드를 사용한다.

```java
class calc {
	int x, y, result;
	void add() {
		result = this.x + this.y;
	}
}

class calc_plus extends calc {
	void sub() {
		result = this.x - this.y;
	}
}
/* 하기 클래스와 위 클래스는 기능적으로 동일함. */
class calc_plus_noExtend {
	int x, y, result;
	void add() {
		result = this.x + this.y;
	}
	void sub() {
		result = this.x - this.y;
	}
}
```

다음과 같이 선언할 경우 calc_plus는 슈퍼클래스 calc의 필드와 메소드를 상속받아 sub이라는 메소드를 추가한 클래스가 된다. 상속을 이용하면 번거롭게 동일한 필드와 메소드를 사용할 필요 없다.

super 키워드는 서브클래스에서 슈퍼클래스를 호출할 때 사용한다. 서브클래스 내에서 슈퍼클래스의 메소드나 필드에 직접 접근할 필요가 있을 때 사용한다.