# C++ 입문 #8 (C++ Module 08)

이번 모듈에서는 컨테이너, 반복자에 대해 다룬다.

## 학습해야 할 내용

- STL
  - 컨테이너
  - 반복자 (이터레이터)
  - 알고리즘
  - 함수 객체

## STL

STL은 표준 템플릿 라이브러리의 약자이며 C++ 표준 라이브러리의 일부이다. STL은 표준화되어 C++의 표준에 포함되어 있기 때문에 C++로 코드를 짠다면 거의 모든 환경에서 STL을 가져다 사용할 수 있다. (과거엔 독립되어 있었다. 제네릭 프로그래밍 연구하던 사람이 C++로 STL을 설계한 것이 표준에 포함되었다.)

STL을 학습하는 것은 상당한 난이도가 있으며 한번에 배우는 데는 무리가 있다. 그래서 차츰차츰 배워야 한다.

STL은 이름에 나타나있다시피 템플릿으로 구현되어 있으며 STL이 제공하는 것은 다음과 같다.

### (자료구조의) 컨테이너

연결 리스트, 큐, 스택 등의 자료구조가 STL에 구현되어 있다. (자바에서 자료구조들이 java.util.* 에 구현되어 있는 것과 유사함)

제네릭과 다형성을 위해 정수나 실수뿐만 아니라 객체도 STL 컨테이너에 담아서 관리할 수 있다. 여러 컨테이너들을 지원해주지만 자주 사용하는 컨테이너들은 다음과 같다.

- vector : 동적 배열처럼 동작한다. 자료들이 배열처럼 메모리에 선형적으로 저장되어 있기 때문에 원소가 추가되거나 제거되면 메모리를 재할당하기 때문에 중간에 자료를 삽입하는 연산이나 삭제하는 연산은 비교적 느리다. 하지만 중간에 있는 요소를 읽어올 때에는 속도가 빠르다.
- list : 이중 연결 리스트처럼 동작한다. 연결 리스트답게 처음과 끝에 자료를 삽입하는 연산은 빠르지만 중간에 있는 요소에 접근할 때에는 느리게 동작된다.
- map : 키-값 쌍을 저장한다. 키 값은 유일한 값을 가져야 한다.

### 반복자 (Iterator)

일반적인 자료구조에 순차적으로 접근하기 위해선 첨자 연산자 "[]" 혹은 포인터를 이용해서 접근한다. 하지만 자료구조의 형태마다 접근할 수 있는 방법이 변하기 때문에 반복자를 제공해서 일관성 있게 자료구조에 순차적으로 접근할 수 있도록 해준다. (자바에도 반복자가 있다.)

예제는 다음과 같다.

```c++
#include <iostream>
#include <vector>
#include <list>
#include <map>

int	main(void)
{
	std::vector<int> vectorInt;
	std::list<float> listFloat;
	std::map<const char *, float> mapkeyValue;

	for (int i = 0; i < 10; i++)
		vectorInt.push_back(i);
	for (float f = 0.0; f < 10.0; f += 1.0)
		listFloat.push_back(f);
	mapkeyValue["pi"] = 3.14;
	mapkeyValue["e"] = 2.718;

	for (std::vector<int>::iterator i = vectorInt.begin(); i != vectorInt.end(); i++)
		std::cout << *i << std::endl;

	for (std::list<float>::iterator i = listFloat.begin(); i != listFloat.end(); i++)
		std::cout << *i << std::endl;

	for (std::map<const char *, float>::iterator i = mapkeyValue.begin(); i != mapkeyValue.end(); i++)
		std::cout << i->first << ", " << i->second << std::endl;
	
	return (0);
}
```

포인터를 사용하는 것처럼 "*" 연산자, 증감 연산자, 감소 연산자가 오버로딩되어 있어 사용할 수 있다.

위에서 보면 반복자는 컨테이너의 한 지점(원소)를 가리키는 포인터 비슷한 것임을 알 수 있다. 밑에서 언급하는 알고리즘 탬플릿 함수들은 반복자를 이용해서 컨테이너의 원소에 접근하기 때문에 일반성이 보장된다.

반복자만의 특징 중 하나가 end 값은 실제 값을 의미하는 것이 아니라는 것이다. 정수에 대해 for문을 쓸 때 조건문에 실제 해당되지 않는 i의 값에 대해선 실행이 되지 않는 것과 동일하다.

그리고 STL이 지원하는 자료구조가 다양한 만큼 컨테이너에 대한 반복자도 반복자에 대해 가능한 연산에 따라 레벨이 나눠지게 된다.

### 알고리즘

STL은 알고리즘을 탬플릿 함수로 제공해 준다. 탬플릿 함수이기 때문에 헤더파일을 열면 바로 함수들의 코드가 보인다. 알고리즘 헤더엔 여러 함수들이 있는데 자주 사용하는 함수만 보자.

- find : 반복자의 시작점, 끝점, 찾을 자료형을 인수로 입력하면 자료가 있는지 찾아준다. 코드를 보면 알겠지만 for문으로 이루어져 있다.
- sort : 반복자의 시작점과 끝점을 인수로 입력하면 알아서 정렬해 준다. 이는 반복자가 포인터처럼 원본 자료 객체를 가리키고 있으므로 가능하다. 내부적으로는 quick sort 기반으로 구현되어 있다.

### 함수 객체

함수 객체는 객체(구조체)에 호출 연산자가 오버로딩되어 함수처럼 사용할 수 있는 객체를 의미한다. 보통 "functors" 라고 부른다.

C++에서 알고리즘 함수와 더불어 이걸 사용하는 이유를 생각해보자. C에서는 함수의 인수로 함수 포인터를 이용해 함수를 집어넣을 수 있다.

그래서 C에서 정렬을 하기 위한 함수인 qsort의 4번째 인자로 함수 포인터를 받을수 있게 되어 있다. 왜냐하면 정렬을 하는데 어느 원소가 더 큰지 기준을 잡아주는것이 있어야 하기 때문이다.

C++의 STL에서는 함수 포인터 대신 함수 객체를 인수로 집어넣는다. 동작은 동일하지만 내부적으로 동작되는 흐름이 다르다.

만약에 함수 포인터를 집어넣으면 함수를 호출하는 데에 비용이 크게 든다. 하지만 함수 객체는 컴파일 시에 함수 객체의 코드가 직접 삽입되어 함수를 호출하는 비용이 사라진다.

또 함수 객체는 함수 포인터와 다르게 처리에 필요한 멤버들을 변수나 함수의 형태로 가질 수 있다.

자주 사용하고 간단한 함수 객체들은 STL에 미리 정의되어 있다. 예를 들면

- minus : 인수의 차
- less / greater : 대소 비교

등이 있다.

### 어댑터

가장 간단하게 어댑터를 설명하자면 "어댑터" 라는 말을 다른 실생활에서 사용하는 예를 생각해보자. 예를 들면 핸드폰/노트북 충전기를 과거엔 "어댑터" 라고 불렀다. 왜 "어댑터"냐 하면 가정용 전기는 한국 기준으로 220V 60Hz 교류를 사용한다. 이 전기를 핸드폰이나 노트북 회로에 그대로 공급하면 회로가 타버린다. 전기를 노트북이나 핸드폰이 사용할 수 있는 10V 전후의 직류로 변환해줘야 한다.

여행용 플러그 어댑터도 마찬가지이다. 이 경우엔 보통 콘센트 형태만 다른 것을 사용해 주도록 하는 "어댑터" 이다.

C++ STL의 어댑터도 이와 유사하다. 함수 객체에서 컨테이너 원소들에 대해 어떤 연산을 하고자 할때 그 연산을 별도로 정의한다면 연산의 입/출력 값을 안정성 있게 함수 객체가 받을 수 있도록 도와주는게 "어댑터" 이다. (함수 객체 외에 반복자와 컴포넌트에 대한 어댑터도 있다.)

## ex00

easyfind라는 템플릿 함수를 만든다. 인수는 타입 T와 정수 i이다. T에서 i를 찾아야 하며 STL 컨테이너를 참조해서 아이디어를 얻는다.

### 학습해야 하는 내용

- STL 컨테이너
  - 컨테이너의 원형
- 이터레이터(반복자)
- typename 키워드

### STL 컨테이너

STL 컨테이너도 자료구조에 따라 시퀀스 컨테이너, 연관 컨테이너, 컨테이너 어댑터로 구분된다. 컨테이너 어댑터는 내부 자료 조회를 허가하지 않고 연관 컨테이너는 문제에서 요구하는 하나의 값을 찾기엔 부적합하므로 시퀀스 컨테이너에 대해 동작하도록 한다.

### 컨테이너의 원형

시퀀스 컨테이너는 모두 다음과 같이 선언되어 있다.

```c++
template <class _Tp, class _Allocator>
class vector
template <class _Tp, class _Allocator>
class deque
template <class _Tp, class _Allocator>
class list
```

시퀀스 컨테이너는 모두 클래스 템플릿이며 타입(`_Tp`)과 할당자(`_Allocator`)를 받아 클래스를 생성한다.

그래서 문제를 보면 타입 T를 받게 되어 있는데 T는 결국 임의의 시퀀스 컨테이너이므로 컨테이너를 easyfind 함수에서 사용할 수 있도록 타입 _Tp와 _Allocator를 집어넣어야 한다.

_Allocator는 기본으로 정의된 것이 존재한다. STL을 분석하다 보면 "memory" 라는 헤더에 다음 코드를 볼 수 있다.

```c++
template <class _Tp>
class allocator
```

그래서 easyfind의 템플릿은 다음과 같이 지정해야 옳다.

```c++
template <template <typename, typename> class T>
```

해석해 보면 템플릿 인자 T가 지정되었는데 이 T라는 템플릿 인자는 임의의 템플릿 인자를 두 개( _Tp, _Allocator) 가지는 타입 (여기서는 typename 대신 클래스 키워드를 사용해야 한다. 템플릿 템플릿 파라미터를 선언하는 데에는 class를 사용해야 한다.)임을 명시한 것이다.

### 이터레이터

이터레이터는 컨테이너 내부 원소에 접근할 수 있는 접근자이다. 시퀀스 컨테이너는 begin() 메소드와 end() 메소드로 원소의 시작점과 끝점(끝점은 마지막 원소가 아니다.)을 제공해 주며 컨테이너에 범위 지정 연산자를 통해 컨테이너에 맞는 이터레이터 형식을 제공해 준다.

### typename 키워드의 추가 기능

문제는 T는 임의의 형식이기 때문에 easyfind 함수를 구성할 때 범위 지정 연산자로 이터레이터 형식을 뽑아 사용할 때 이터레이터가 타입인지 멤버변수인지 멤버함수인지 구분이 되지 않는다.

그래서 템플릿을 이용해 클래스나 함수를 만들 때 템플릿 파라미터에 접근해 다른 형식을 사용할 때 예를 들면 꼭 다음과 같이 타입임을 명시해줘야 한다.

```c++
typename T<int, std::allocator<int>>::iterator iter;
```

### easyfind 함수의 인수

컨테이너를 일반 변수 형태로 받으면 함수 콜스택에 컨테이너가 복제된다. 원본 컨테이너에 접근할 수 있도록 레퍼런스 타입으로 받아야 한다.

### STL 사용

문제에서 필요한 경우 STL을 사용하라고 하였으므로 algorithm의 find 함수를 이용해 구현한다.

## ex01

컨테이너를 이용해 Span이라는 일종의 컨테이너를 만들어라. 예외 처리도 되어야 하며 내부 원소의 거리를 출력해주는 함수를 가지고 있다.

## ex02

STL의 Stack을 이용해(상속받아) MutantStack이라는 컨테이너를 만들어라. 단순히 Stack에 이터레이터를 더한 것처럼 동작되어야 한다. (팁 : STL의 스택은 보통 덱을 이용해 만든다. Stack 멤버 변수를 잘 봐서 적절히 호출시켜서 구현하면 됨)