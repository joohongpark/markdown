# 프로그램 병렬 처리에 대한 고민 (Philosophers)

우리가 보통 프로그램을 만들 때 하나의 프로그램이 실행되는 순간(이걸 Runtime이라고 한다고 한다. Runtime은 "시간" 외에도 그 프로그램을 실행하는 환경을 말하기도 한다.)에 하나의 기능만 동작되는 것을 가정하고 프로그램을 만든다. 

예를 들어 쉘로 계산기 프로그램을 만든다 생각해보자. 쉘 표준입력으로 식을 받을 때 까지 아무런 동작을 하지 않고 표준입력에 무엇인가가 들어와야 계산하는 동작을 수행한다. 이런 프로그램들은 프로그램이 실행되는 순간순간에 하나의 기능만 실행되면 될것이다.

근데 우리가 실제로 사용하는 다른 프로그램들을 보자. C로 만들었든 자바로 만들었든 상용 프로그램들은 그 프로그램이 실행되는 순간에 단 하나의 기능만 하는 경우는 거의 없다.

게임을 할 때도 "게임" 이라는 기능을 수행하기 위해 내부적으로 다른 사용자와 통신하기 위한 네트워크 파트, 음악이나 효과음을 재상하기 위한 파트, 화면에 무엇인가를 출력하기 위한 파트 등 하나의 프로그램 내에 여러가지 기능들이 내장되어 있고 이것들은 프로그램 런타임에 동시에 실행되는 것처럼 보인다.

또 우리가 nginx를 이용해 http 서버를 구동시킬 때를 생각해 보자. (ft_server나 ft_service) nginx를 구동시킬 때 ps 명령어로 실행되고 있는 프로그램들을 보면 ngnix 프로세스가 여러개 실행된 것을 볼 수 있다.

하나의 프로그램에 한가지 기능을 넣으면 그 기능을 실행시킬 떄 while문 같은걸로 blocking 하면 아무 문제가 없다. 하지만 여러가지 기능을 실행시키고자 할 때 문제가 된다.

하나의 프로그램에 여러 가지 기능을 넣을 때 해결 방법은 대략 두가지가 있다. 하나는 프로세스 자체를 fork 시켜서 동일한 프로그램을 하나 더 실행시키는 것이다. fork 되는 분기점부터 같은 프로그램이지만 두 프로그램은 서로 다른 기능을 수행할 것이다.

이런 경우 구현 자체는 쉽다. 하지만 서로 다른 기능끼리 무엇인가 상호 작용을 해야 한다면 다소 문제가 된다. 그렇게 하려면 프로세스끼리 통신을 하게 해야 한다. (이를 IPC라고 한다.)

또 fork는 프로세스를 통째로 복사하는 것이기 때문에 메모리 등 자원의 낭비가 심하다. 또 fork를 지원하지 않는 런타임도 있을 것이다. (fork는 fork라는 시스템 콜을 호출하는 것이기 때문이다. node.js같은거 말고 브라우저 런타임에서 실행되는 js가 시스템 콜을 호출할 수 있을까?)

그래서 특별한 경우가 아니면 대부분 두번째 방식인 thread를 이용한다. thread는 하나의 프로세스 내에서 프로세스의 자원 (전역변수 등을 공유한다. 정확히는 코드, 데이터, 힙 영역을 공유한다.)들을 공유하며 동작된다. 그래서 하나의 프로세스 내에서 여러개의 기능을 동시에 실행시킬 수 있다. 또 fork 시키는 것보다 자원 소모도 적고 더 빠르다. (싱글스레드와 멀티스레드 차이. thread를 사용하는 것을 멀티스레드라고 한다.)

근데 프로세스의 자원들을 공유하는것이 장점이자 단점이 된다. 기능들이 여러개 실행되고 있으면 하나의 프로세스 자원에 접근할 때 충돌할 수 있는 여지가 너무 많다. Philosophers에서 요구하는 것은 멀티스레드를 사용할 때 기능들을 어떻게 컨트롤 할 것인지를 요구한다.

## 왜 Philosophers를 공부해야 하나?

우리가 현직에서 만드는 프로그램들은 대부분 하나의 프로그램이 하나의 기능만 수행하지 않을 것이다. 또 멀티스레딩은 언어와 분야를 구분하지 않고 매우 폭넓게 사용되는 개념이며 중요한 개념이다. FE단에서 자바스크립트에서 비동기통신 async await promise 어쩌고 하는 것도 본질적으로는 여러 기능들을 한 프로세스에서 동시에 실행시키고자 하는 문제이자 키워드이다. (참고로 자바스크립트는 싱글쓰레드만을 지원한다.) 당연히 여러 언어나 분야에서 Philosophers에서 필요한 개념, 구현할 기능을 다른데서 곧바로 사용하진 않겠지만 적어도 생각의 폭을 넓히고 "하나의 프로그램에서 여러개의 기능을 동작" 시키고자 할 때 문제 접근법에 대한 질이 달라질 것이라 기대하고 있으며 나는 현재 이 분야에 대해 아무것도 모르는 상황이기 때문에 멀티스레딩을 맛보기에 큰 도움이 될 것이라 생각한다.

## 문제 분석

총 세 가지 프로그램을 만들어야 한다. 세 가지 프로그램 모두 공통적으로 따라야 하는 사항들이 있다. (참고로 이 문제는 운영체제 스레드 부분의 단골 예시로 나오는 "식사하는 철학자들 문제" 를 기반으로 한다. 검색을 통해 철학자들이 식탁에 앉아 있는 것을 참조해보자.)

### 공통 사항

- Libft를 import해서 사용할 수 없으며 각 제출물은 별도에 폴더에 넣어서 제출한다.
- 철학자들은 하나의 스파게티가 있는 식탁에 둥글게 앉아 있으며 세 가지 동작을 할 수 있다. 철학자들이 하는 세 가지 동작은 동시에 할 수 없다.
  - 식사하기
  - 생각하기
  - 자기
- 철학자들은 스파게티를 먹을 때 포크를 양손에 들고 먹어야 한다. (포크가 두개 필요하다)
- 철학자들은 모두 스파게티를 먹을 수 있어야 하고 굶주리면 안된다. (굶주리면 죽는다.)
- 철학자들끼리 소통해서는 안된다.
- 철학자는 다른 철학자가 죽었는지 알 수 없다.
- 철학자는 식사를 다 했으면 포크를 놓고 잠든다. 잠애서 깨면 생각하는 시간을 가진다.
- 철학자가 한 명이라도 죽는다면 실행을 멈춘다.
- 프로그램은 다음 인수들을 받아야 한다.
  - 철학자의 수(number_of_philosophers) : 철학자의 수이자 포크의 개수
  - 철학자 밥먹는 쿨타임 (time_to_die) : 식사를 시작한 시점/시뮬레이션을 시작한 시점부터 ms 단위로 저 시간을 넘기면 철학자는 굶어 죽는다.
  - 철학자 밥먹는 시간 (time_to_eat) : 철학자가 밥먹는데 걸리는 시간, ms 단위임.
  - 철학자 자는 시간 (time_to_sleep) : 철학자가 잠자는 시간, ms 단위임
  - 철학자의 최소 식사 횟수 (number_of_times_each_philosopher_must_eat) : 모든 철학자들이 여기 명시된 식사 횟수를 채운다면 시뮬레이션은 종료됨. 이 인수는 선택사항임.

### philo_one (스레드와 뮤텍스 이용)

- 포크들은 철학자 옆에 놓여있다. 무슨 말이냐면 철학자 - 포크 - 철학자 - 포크 - ... 순으로 놓여있어 철학자 양 옆에 포크가 위치한다는 말이다.
- mutex를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 스레드로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - pthread_create
  - pthread_detach
  - pthread_join
  - pthread_mutex_init
  - pthread_mutex_destroy
  - pthread_mutex_lock
  - pthread_mutex_unlock

### philo_two (스레드와 세마포어 이용)

- 포크들은 모두 테이블 중앙에 있다.
- semaphore를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 스레드로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - pthread_create
  - pthread_detach
  - pthread_join
  - sem_open
  - sem_close
  - sem_post
  - sem_wait
  - sem_unlink

### philo_three (자식 프로세스와 세마포어 이용)

- 포크들은 모두 테이블 중앙에 있다.
- semaphore를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 자식 프로세스로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - fork
  - kill
  - exit
  - waitpid
  - pthread_create
  - pthread_detach
  - pthread_join
  - sem_open
  - sem_close
  - sem_post
  - sem_wait
  - sem_unlink

## gettimeofday()

gettimeofday 시스템 콜은 settimeofday와 함께 널리 쓰이는 시스템 시간을 구하는 (settimeofday는 시스템 시간을 설정하는) 시스템 콜이다.

컴퓨터에서의 내부적인 시간(년월일)은 보통 유닉스 시간 (POSIX 시간이라고도 부름)을 기준으로 한다. 유닉스 시간은 1970년 1월 1일 0시 0분 0초를 기준(그리니치 표준시 기준)으로 현재 시간까지의 차를 초로 표현한 것이다.

예를 들면 2021년 4월 12일 am 2시는 1618161487로 나타낼 수 있으며 이 수치는 1970년부터 현재까지의 지난 초 수치를 나타낸 것이다.

gettimeofday이든 settimeofday이든 유닉스 시간 기준으로 시간을 다룬다.

인수로 주어지는 구조체에 현재 시간과 시간 위치 정보 (타임존)를 이용해서 시간을 읽거나 쓴다. timezone은 잘 사용하지 않으므로 NULL로 넣어도 괜찮다.

이 시스템 콜을 이용해서 타이머처럼 사용한다. (코드와 코드 사이 간 절대적인 시간으로 얼마나 흘럿는지 파악한다.)

## usleep()

메뉴얼 (man 3 sleep)을 참조하면 usleep 함수는 `suspend thread execution for an interval measured in microseconds` 라고 설명되어 있다. 인수로 주어진 초 만큼 스레드의 실행을 잠시 중단한다는 의미이다.

여러 포럼 등을 참조해 보면 sleep는 절대 정확하지 않다. 괄호 내 이상의 시간을 sleep 시켜주는 것을 보증해 줄 뿐이며 스레드의 실행을 늦추는 것이기 때문에 다른 스레드에 밀려 더 늦게 실행되는 경우도 있는 것 같다.

sleep 함수의 자세한 구현방식은 운영체제나 라이브러리마다 다른것 같으며 너무 방대한 내용이기 때문에 위 영어 설명 정도로만 이해하면 될 듯 하다.

아마도 이 함수는 철학자들이 소비하는 시간에서 busy waiting을 사용하지 않기 위해 사용하는 듯 하다. 하지만 이 함수는 부정확하기 때문에 slack 포럼을 참조해본 결과 큰 오차로 인해 그냥 busy waiting을 사용하는 분들도 계시는 듯 하다.

## pthread

pthread는 posix thread이다. 유닉스나 리눅스에서 표준적으로 스레드를 생성할 때 사용하는 라이브러리이다.

컴파일을 할 때 스레드 라이브러리를 링크해야 한다.

