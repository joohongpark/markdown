# 프로그램 병렬 처리에 대한 고민 (Philosophers)

우리가 보통 프로그램을 만들 때 하나의 프로그램이 실행되는 순간(이걸 Runtime이라고 한다고 한다. Runtime은 "시간" 외에도 그 프로그램을 실행하는 환경을 말하기도 한다.)에 하나의 기능만 동작되는 것을 가정하고 프로그램을 만든다. 

예를 들어 쉘로 계산기 프로그램을 만든다 생각해보자. 쉘 표준입력으로 식을 받을 때 까지 아무런 동작을 하지 않고 표준입력에 무엇인가가 들어와야 계산하는 동작을 수행한다. 이런 프로그램들은 프로그램이 실행되는 순간순간에 하나의 기능만 실행되면 될것이다.

근데 우리가 실제로 사용하는 다른 프로그램들을 보자. C로 만들었든 자바로 만들었든 상용 프로그램들은 그 프로그램이 실행되는 순간에 단 하나의 기능만 하는 경우는 거의 없다.

게임을 할 때도 "게임" 이라는 기능을 수행하기 위해 내부적으로 다른 사용자와 통신하기 위한 네트워크 파트, 음악이나 효과음을 재상하기 위한 파트, 화면에 무엇인가를 출력하기 위한 파트 등 하나의 프로그램 내에 여러가지 기능들이 내장되어 있고 이것들은 프로그램 런타임에 동시에 실행되는 것처럼 보인다.

또 우리가 nginx를 이용해 http 서버를 구동시킬 때를 생각해 보자. (ft_server나 ft_service) nginx를 구동시킬 때 ps 명령어로 실행되고 있는 프로그램들을 보면 ngnix 프로세스가 여러개 실행된 것을 볼 수 있다.

하나의 프로그램에 한가지 기능을 넣으면 그 기능을 실행시킬 떄 while문 같은걸로 blocking 하면 아무 문제가 없다. 하지만 여러가지 기능을 실행시키고자 할 때 문제가 된다.

하나의 프로그램에 여러 가지 기능을 넣을 때 해결 방법은 대략 두가지가 있다. 하나는 프로세스 자체를 fork 시켜서 동일한 프로그램을 하나 더 실행시키는 것이다. fork 되는 분기점부터 같은 프로그램이지만 두 프로그램은 서로 다른 기능을 수행할 것이다.

이런 경우 구현 자체는 쉽다. 하지만 서로 다른 기능끼리 무엇인가 상호 작용을 해야 한다면 다소 문제가 된다. 그렇게 하려면 프로세스끼리 통신을 하게 해야 한다. (이를 IPC라고 한다.)

또 fork는 프로세스를 통째로 복사하는 것이기 때문에 메모리 등 자원의 낭비가 심하다. 또 fork를 지원하지 않는 런타임도 있을 것이다. (fork는 fork라는 시스템 콜을 호출하는 것이기 때문이다. node.js같은거 말고 브라우저 런타임에서 실행되는 js가 시스템 콜을 호출할 수 있을까?)

그래서 특별한 경우가 아니면 대부분 두번째 방식인 thread를 이용한다. thread는 하나의 프로세스 내에서 프로세스의 자원 (전역변수 등을 공유한다. 정확히는 코드, 데이터, 힙 영역을 공유한다.)들을 공유하며 동작된다. 그래서 하나의 프로세스 내에서 여러개의 기능을 동시에 실행시킬 수 있다. 또 fork 시키는 것보다 자원 소모도 적고 더 빠르다. (싱글스레드와 멀티스레드 차이. thread를 사용하는 것을 멀티스레드라고 한다.)

근데 프로세스의 자원들을 공유하는것이 장점이자 단점이 된다. 기능들이 여러개 실행되고 있으면 하나의 프로세스 자원에 접근할 때 충돌할 수 있는 여지가 너무 많다. Philosophers에서 요구하는 것은 멀티스레드를 사용할 때 기능들을 어떻게 컨트롤 할 것인지를 요구한다.

## 왜 Philosophers를 공부해야 하나?

우리가 현직에서 만드는 프로그램들은 대부분 하나의 프로그램이 하나의 기능만 수행하지 않을 것이다. 또 멀티스레딩은 언어와 분야를 구분하지 않고 매우 폭넓게 사용되는 개념이며 중요한 개념이다. FE단에서 자바스크립트에서 비동기통신 async await promise 어쩌고 하는 것도 본질적으로는 여러 기능들을 한 프로세스에서 동시에 실행시키고자 하는 문제이자 키워드이다. (참고로 자바스크립트는 싱글쓰레드만을 지원한다.) 당연히 여러 언어나 분야에서 Philosophers에서 필요한 개념, 구현할 기능을 다른데서 곧바로 사용하진 않겠지만 적어도 생각의 폭을 넓히고 "하나의 프로그램에서 여러개의 기능을 동작" 시키고자 할 때 문제 접근법에 대한 질이 달라질 것이라 기대하고 있으며 나는 현재 이 분야에 대해 아무것도 모르는 상황이기 때문에 멀티스레딩을 맛보기에 큰 도움이 될 것이라 생각한다.

## 문제 분석

총 세 가지 프로그램을 만들어야 한다. 세 가지 프로그램 모두 공통적으로 따라야 하는 사항들이 있다. (참고로 이 문제는 운영체제 스레드 부분의 단골 예시로 나오는 "식사하는 철학자들 문제" 를 기반으로 한다. 검색을 통해 철학자들이 식탁에 앉아 있는 것을 참조해보자.)

### 공통 사항

- Libft를 import해서 사용할 수 없으며 각 제출물은 별도에 폴더에 넣어서 제출한다.
- 철학자들은 하나의 스파게티가 있는 식탁에 둥글게 앉아 있으며 세 가지 동작을 할 수 있다. 철학자들이 하는 세 가지 동작은 동시에 할 수 없다.
  - 식사하기
  - 생각하기
  - 자기
- 철학자들은 스파게티를 먹을 때 포크를 양손에 들고 먹어야 한다. (포크가 두개 필요하다)
- 철학자들은 모두 스파게티를 먹을 수 있어야 하고 굶주리면 안된다. (굶주리면 죽는다.)
- 철학자들끼리 소통해서는 안된다.
- 철학자는 다른 철학자가 죽었는지 알 수 없다.
- 철학자는 식사를 다 했으면 포크를 놓고 잠든다. 잠애서 깨면 생각하는 시간을 가진다.
- 철학자가 한 명이라도 죽는다면 실행을 멈춘다.
- 프로그램은 다음 인수들을 받아야 한다.
  - 철학자의 수(number_of_philosophers) : 철학자의 수이자 포크의 개수
  - 철학자 밥먹는 쿨타임 (time_to_die) : 식사를 시작한 시점/시뮬레이션을 시작한 시점부터 ms 단위로 저 시간을 넘기면 철학자는 굶어 죽는다.
  - 철학자 밥먹는 시간 (time_to_eat) : 철학자가 밥먹는데 걸리는 시간, ms 단위임.
  - 철학자 자는 시간 (time_to_sleep) : 철학자가 잠자는 시간, ms 단위임
  - 철학자의 최소 식사 횟수 (number_of_times_each_philosopher_must_eat) : 모든 철학자들이 여기 명시된 식사 횟수를 채운다면 시뮬레이션은 종료됨. 이 인수는 선택사항임.

### philo_one (스레드와 뮤텍스 이용)

- 포크들은 철학자 옆에 놓여있다. 무슨 말이냐면 철학자 - 포크 - 철학자 - 포크 - ... 순으로 놓여있어 철학자 양 옆에 포크가 위치한다는 말이다.
- mutex를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 스레드로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - pthread_create
  - pthread_detach
  - pthread_join
  - pthread_mutex_init
  - pthread_mutex_destroy
  - pthread_mutex_lock
  - pthread_mutex_unlock

### philo_two (스레드와 세마포어 이용)

- 포크들은 모두 테이블 중앙에 있다.
- semaphore를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 스레드로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - pthread_create
  - pthread_detach
  - pthread_join
  - sem_open
  - sem_close
  - sem_post
  - sem_wait
  - sem_unlink

### philo_three (자식 프로세스와 세마포어 이용)

- 포크들은 모두 테이블 중앙에 있다.
- semaphore를 사용해서 제한된 포크 개수로 모든 철학자들이 굶어 죽는 일이 없도록 한다.
- 철학자는 자식 프로세스로 동작한다.
- 사용 가능한 함수
  - memset
  - printf
  - malloc
  - free
  - write
  - usleep
  - gettimeofday
  - fork
  - kill
  - exit
  - waitpid
  - pthread_create
  - pthread_detach
  - pthread_join
  - sem_open
  - sem_close
  - sem_post
  - sem_wait
  - sem_unlink

## gettimeofday()

gettimeofday 시스템 콜은 settimeofday와 함께 널리 쓰이는 시스템 시간을 구하는 (settimeofday는 시스템 시간을 설정하는) 시스템 콜이다.

컴퓨터에서의 내부적인 시간(년월일)은 보통 유닉스 시간 (POSIX 시간이라고도 부름)을 기준으로 한다. 유닉스 시간은 1970년 1월 1일 0시 0분 0초를 기준(그리니치 표준시 기준)으로 현재 시간까지의 차를 초로 표현한 것이다.

예를 들면 2021년 4월 12일 am 2시는 1618161487로 나타낼 수 있으며 이 수치는 1970년부터 현재까지의 지난 초 수치를 나타낸 것이다.

gettimeofday이든 settimeofday이든 유닉스 시간 기준으로 시간을 다룬다.

인수로 주어지는 구조체에 현재 시간과 시간 위치 정보 (타임존)를 이용해서 시간을 읽거나 쓴다. timezone은 잘 사용하지 않으므로 NULL로 넣어도 괜찮다.

이 시스템 콜을 이용해서 타이머처럼 사용한다. (코드와 코드 사이 간 절대적인 시간으로 얼마나 흘럿는지 파악한다.)

## usleep()

메뉴얼 (man 3 sleep)을 참조하면 usleep 함수는 `suspend thread execution for an interval measured in microseconds` 라고 설명되어 있다. 인수로 주어진 초 만큼 스레드의 실행을 잠시 중단한다는 의미이다.

여러 포럼 등을 참조해 보면 sleep는 절대 정확하지 않다. 괄호 내 이상의 시간을 sleep 시켜주는 것을 보증해 줄 뿐이며 스레드의 실행을 늦추는 것이기 때문에 다른 스레드에 밀려 더 늦게 실행되는 경우도 있는 것 같다.

sleep 함수의 자세한 구현방식은 운영체제나 라이브러리마다 다른것 같으며 너무 방대한 내용이기 때문에 위 영어 설명 정도로만 이해하면 될 듯 하다.

아마도 이 함수는 철학자들이 소비하는 시간에서 busy waiting을 사용하지 않기 위해 사용하는 듯 하다. 하지만 이 함수는 부정확하기 때문에 slack 포럼을 참조해본 결과 큰 오차로 인해 그냥 busy waiting을 사용하는 분들도 계시는 듯 하다.

## pthread

pthread는 posix thread이다. 유닉스나 리눅스에서 표준적으로 스레드를 생성할 때 사용하는 라이브러리이다.

컴파일을 할 때 스레드 라이브러리를 링크해야 한다.

## FSM (Finite-State Machine / 유한 상태 기계)

기계 혹은 프로그램 혹은 함수 등이 어떠한 사건으로 인해 상태가 변환이 되고 그 순간에 하나의 상태를 가지게 되는 것을 유한 상태 기계라고 한다.

FSM은 보통은 FPGA 등을 이용해 논리회로를 설계할 때 주로 사용하는 개념이다.

학부생 때 논리회로 시간에 배운 개념이 생각나서 철학자는 특정 순간의 특정 상태를 가지며 특정 사건에 따라 상태가 변화하므로 FSM이 연상되어 FSM처럼 구현하였다.

## Deadlock 회피 방법

만약 철학자들이 같은 시간에 같은 방향의 포크를 든다면 바로 교착 상태에 빠지게 될 것이며 모든 철학자들은 굶어 죽을 것이다. 식사하는 철학자 문제에서 가장 기본적으로 교착 상태를 회피하는 방법은 철학자 순서를 짝/홀수 그룹으로 구분하여 한 그룹이 왼쪽 포크를 먼저 집는다면 다른 그룹은 오른쪽 포크를 집게 한다. 이 방법으로는 교착 상태는 회피할 수 있다. (당연히 포크를 집고 놓는 행동은 원자화해야 한다.)

## 기아상태 억제 방법

하지만 위 방법으로 기아 상태를 충분히 방어하지 못한다. 예를 들면 철학자가 5명일 때 위 방법을 적용하면 얼마 안 가 어느 한 철학자는 굶어 죽을 것이다. 애초에 조건을 절대로 기아상태를 막을 수 없도록 주어지는 경우를 제외하고는 최대한 기아상태를 억제하여야 한다. (조건이 다양하고 자원이 한정되어 있는 동기화 문제에서 기아상태를 아예 방지하는 방법은 보통 없다고 한다. Trade-Off 하여야 한다.)

보통 이 상황에서 가장 좋은 방법은 철학자들에게 우선순위를 부여하여 기아상태가 비교적 오래 지속된 철학자에게 포크를 집을 권리를 부여한다. 하지만 이 과제에서 철학자들 간 소통은 불가하므로 이 방법은 사용하면 안된다.

C에서 thread를 생성하면 매우 빠른 속도로 생성되므로 거의 동시에 생성되는 것처럼 보인다. 그래서 철학자를 여러 명 만들 때 그 많은 철학자들이 거의 동시에 식사를 하려 할 것이다. 철학자가 홀수명일 때 데드락은 걸리지 않더라도 어느 한 철학자는 포크 집는 타이밍이 어긋나 잡지 못하게 될 것이다.

이를 최대한 억제하려면 철학자 스레드가 생성될 때 약간의 딜레이를 주어 철학자들이 약간의 간격을 가지고 생성하게 한다.

## 시행착오

데드락을 회피하기 위해 짝/홀수로 구분할 때 철학자들이 약간의 간격을 가지면 프로세스가 기아 상태에 빠질 확률이 커진다. 철학자들의 비대칭성과 철학자들의 생성 시간 차가 기아를 유발하게 된다. 만약에 철학자의 생성시에 딜레이를 주게 되면 철학자들이 데드락에 빠질 수 없기 때문에 이런 상황에서는 짝수/홀수 구분을 하면 안된다.

## 시행착오 2

위 시행착오를 겪고 다양한 테스트케이스에서 동작시켰다. 하지만 스레드 간 지연 혹은 문맥 전환에 따른 지연 등으로 데드락이 발생가는 문제가 발생한다. 이런 상황을 해결하기 위해 다시 짝/홀수를 구분하는 기능을 넣었다. 그리고 포크를 내려놓을 때 기존엔 하나씩 내려놓았지만 중간에 다른 스레드가 접근을 할 수도 있는 문제가 있어 스레드를 공통으로 묶어 완전히 한 순간에 내려 놓는 식으로 변경하였다. 또 딜레이를 유동적으로 부여하게 변경하였다.

## philo_two 시행착오

philo_one은 한 스레드에서 감시까지 처리하게 하였다. 가능한 이유는 철학자 하나당 하나의 포크가 부여되기 때문이다. 하지만 philo_two는 포크의 개수를 세마포어로 관리해야 한다. 이게 왜 문제가 되냐면 만약에 포크를 모두 사용하고 있으면 블록킹이 되기 때문에 스레드 내에 별도의 감시용 스레드를 하나 더 만들어야 한다.

## philo_three 시행착오

세마포어 S (sem_t 자료형)가 정수라고 해도 함부로 정수로 캐스팅해서 접근하면 안된다. 왜 안되는걸까? 커널단에서 거부하는건가? 아무튼 안된다. 모른다.

프로세스와 프로세스간의 통신은 세마포어만을 이용해서 동기화를 해야 하기 때문에 철학자간의 동기화는 1, 2번보다 더 까다롭다.

나는 부모 프로세스에서 자식 프로세스들 (철학자들)의 최소 식사 감지와 die 감지를 하는 스레드를 각각 만들어 감지하도록 했다. 철학자 프로세스는 die되면 종료되며 종료 여부는 waitpid로 판단하게 했다. 최소 식사 감지는 세마포어 blocking 여부로 확인하게 했다.

## context switch와 usleep의 균형

스레드든 프로세스든 멀티태스킹을 할 때 context switch가 발생한다. context switch 자체로 당연히 오버헤드가 있지만 내가 보기엔 가장 문제가 되는 점은 태스크들을 운영체제가 관리하기 때문에 여러 개의 프로세스나 스레드들이 wait 상태로 빠질 때 정확히 언제 나올지 모른다는 것이다.

이게 이 과제에서 가장 큰 걸림돌이 되는 문제이다. 스레드나 프로세스를 조금만 생성하면 해결할 수 있지만 (하지만 이는 실행환경에 따라 큰 차이가 있다. 또 이는 근본적인 해결방안이 되지 않는다.) 스레드나 프로세스가 꽤 많이 생겨 그 프로세스들을 모두 실행하는데 지연이 생기는 것이 문제이다.

예를 들어 주기적으로 (10ms) 상태를 갱신해야 하는 프로세스가 여러 개 있으면 이 프로세스들을 스케줄링 하는 도중에 10ms를 초과하는 경우가 발생할 수도 있다.

시간을 측정하는 구문에서 보통은 while과 usleep을 조합해 비교적 정확하게 시간 측정을 되도록 할텐데 이런 경우에 조심해야 한다. 문맥 전환이 많을수록 오차가 심해질 수도 있다.

