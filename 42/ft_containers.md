# STL 컨테이너 비슷한 거 만들어 보기 (ft_containers)

C++98 표준 기반으로 STL 컨테이너의 List, Vector, Map, Stack, Queue를 직접 만들어 본다.

## 규칙

- C++98 표준으로 작성해야 함.
- 헤더 보호 (ifndef ~ define ~ endif) 사용
- 템플릿을 제외하고 함수의 기능구현은 *.cpp에 적어야 함.
- 파일 이름과 클래스 이름은 같아야 함.
- (당연하지만) STL 컨테이너를 쓰지 말기
- 사용 금지된 함수 쓰지 말기
- 네임스페이스 키워드와 friend 키워드 쓰지 말기 (단, 이 과제에선 friend 키워드는 non-member 함수 오버로드엔 써도 됨)
- clang++ -Wall -Werror -Wextra 로 컴파일 함.
- 무엇인가를 include 할 때 그 기능을 동작하기 위한 무엇인가는 내부적으로 include 되어있어야 함. (STL에서 vector include vector를 위한 다른 헤더를 인클루드 할 필요 없는것처럼)
- 규칙을 위반하지 않는 한 코딩룰이 없는 만큼 자유롭게 짜도 되는데 피어 평가를 감안하여 가독성이 좋게 짤 것
- C++98에서 구현하고자 하는 컨테이너들이 가지고 있는 기능 모두 구현해야 함.
- 클래스들은 코플리언 폼을 지켜야 함.
- 구현하는 컨테이너들의 네임스페이스는 `ft` 임. 예를 들면 `std::vector` 처럼 `ft::vector` 로 동작되도록 함.
- 동작을 증명할 main.cpp가 필요함.
- get_allocator는 구현할 필요가 없어 std::allocator를 가져다 써도 됨 근데 다른건 모두 구현하고 멤버함수가 아닌 오버로드도 구현해야 함.
- (컨테이너가 인터레이터를 가지고 있을 시에) 이터레이터 재구현
- STL 컨테이너와 동일하게 public 멤버함수를 가지고 있어야 한다. 그 외에는 private나 protected로 설정해야 함.
- 위에도 말했지만 friend 키워드는 특수한 상황에서만 사용가능함.

## 학습해야 하는 내용

- C++의 네임스페이스
- STL
  - STL 컨테이너의 구조

## C++의 네임스페이스

프로그래밍을 하다 보면 변수명이나 함수명이 겹치는 일이 많다. 원인 중 하나가 예를 들면 C에서 독자적으로 printf 라는 함수를 만든다고 생각해보자. 근데 이 printf라는 함수는 C 표준 라이브러리에 있는 printf와 이름이 겹친다. 내가 만든 printf 라는 함수를 라이브러리화 해서 여기저기서 가져다 쓰고 싶은데 표준 함수와 이름이 겹친다. 그래서 기존엔 함수명에 정체성을 나타내는 식으로 명명하는 식으로 하곤 한다. 예를 들면 my_printf 와 같은 식으로 짓거나 할 수 있다.

근데 내가 만든 printf라는 함수를 다른 프로젝트에서 쓰고자 할때 기존 프로젝트의 printf로 사용된 함수명을 my_printf로 뜯어 고치고는 해야 한다. 이런 작업은 매우 비효율적이다.

C++에는 네임스페이스라는 개념이 있다. 네임스페이스를 직역하면 "이름공간" 이고 뭔가 어색하지만 "고유한 함수나 변수 등을 가리킬 수 있는 공간"의 의미로 풀어볼 수 있다.

"네임스페이스" 라는 개념은 C++에 종속적인것도 아니고 컴퓨터 관련해서 광범위하게 사용되는 개념이다. C++의 네임스페이스는 함수나 변수, 클래스를 네임스페이스라는 공간에서 구분되는 것는 것을 의미한다.

예를 들어 C++의 표준 클래스나 객체에 접근할 때를 생각해 보자. 표준 클래스나 객체를 사용하기 위해 여러 헤더를 include 하기만 한다고 그 클래스나 객체들을 바로 사용할 수 없다. 표준 라이브러리는 `std` 라는 네임스페이스 내에 정의되어 있다.

그래서 표준 클래스나 객체를 사용하려면 범위 지정 연산자 :: 를 사용해서 std라는 네임스페이스에 속해 있는 것을 가져다 사용한다라고 명시해 주거나 `using namespace std` 키워드를 이용해 현재 코드에서 std 라이브러리 내부에 있는 것들을 전역적으로 사용할 수 있도록 해야 한다.

### C++ 네임스페이스 사용법

네임스페이스 안에 넣고자 하는 클래스, 함수, 변수를 넣으면 된다. 네임스페이스를 별도로 지정하지 않으면 그 클래스, 함수, 변수는 전역 네임스페이스 소속이 된다.

```c++
#include <iostream>

namespace ns { // 네임스페이스 ns 지정 (정수 1개, 클래스 1개)
	int i;
}

namespace ns {
	class test {
		private:
			int val;
		public:
			test(int arg) : val(arg) {};
			int getval(void) {return(val);}
	};
}

int i;

int main(void) {
	::i = 10; // 전역 네임스페이스
	ns::i = 20; // 네임스페이스 ns
	ns::test t(30); // 네임스페이스 ns
	std::cout << ::i << std::endl;
	std::cout << ns::i << std::endl;
	std::cout << t.getval() << std::endl;
	return (0);
}
```

