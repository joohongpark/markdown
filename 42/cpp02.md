# C++ 입문 #2 (C++ Module 02)

## (C++98 버전 기준임.)

## C++ Module 02에 대한 추가 룰

앞으로 모든 클래스를 반드시 캐노니컬 (coplien) 형태로 적어야 한다. 최소한 하나의 기본 생성자, 복사 생성자, 할당 연산자 오버로딩, 파괴자를 구현해 놓아야 한다.

## 추가 룰 해설

### 캐노니컬 폼 (canonical form)

캐노니컬 폼이라는 용어는 컴퓨터 과학에서만 쓰이는 용어는 아니다. 캐노니컬 폼을 한국어로 번역하면 "표준 형식" 인데 말 그대로 표준적인 형식을 의미한다.

### C++ 캐노니컬 폼

C++은 여러 형태로 쓸 수 있고 생성자와 소멸자가 필수는 아니다. 하지만 여기에서는 James O. Coplien 이라는 사람이 Advanced C++ 라는 책에서 설명한 형태 (클래스를 생성할 때 기본 생성자, 복사 생성자, 할당 연산자 오버로딩, 파괴자를 구현)를 따라야 한다는 말이다.

### 기본 생성자

클래스가 인스턴스화 될 때 (클래스가 변수로써 함수 내부에서 선언이 되어 스택 영역에 할당이 될 때나 혹은 new 연산자로 힙 영역에 할당이 될 때) 클래스의 생성자라는 일종의 함수를 호출하여 내부 멤버 변수를 초기화 할 수 있다.

### 복사 생성자

동일한 클래스에서 생성된 인스턴스 A가 있고 A와 동일한 값을 가지고 있지만 독립적인 인스턴스 B를 만들 때 선언 시 A = B 혹은 A(B); 형태로 인스턴스를 복사할 수 있다. 이런 상황에선 생성자의 인수로 클래스 형식의 인스턴스가 들어간 상황이 된다. C++에선 기본적으로 이런 상황에선 멤버 변수들을 복사해 준다. 하지만 멤버 변수 중 포인터가 있을 때 문제가 될 수 있다. 이런 상황에선 포인터의 주소만을 복사해 주기 때문에 A, B 객체 모두 동일한 메모리 주소를 가리킨다.

이런 상황에선 본질적으로 독립적인 객체가 아니게 되므로 사용자가 별도로 복사 생성자를 선언하여야 한다. 복사 생성자 내에서 독립적으로 복사를 할 수 있는 별도의 연산을 삽입하여야 한다.

일반적으로 C++의 복사 생성자의 인수는 다음과 같다.

```c++
Classname:Classname(const Classname& val)
```

입력 인수를 상수 + 참조자로 받게 된다. 입력 인수를 변화시키지 않을 것이고 변화시키면 안되므로 상수로 받으며 참조자로 받아야 하는 이유는 만약 참조자가 아니라면 복사 생성자가 호출될 때 생성자의 지역변수로 Classname 형태의 객체를 또 생성하게 된다. 또 생성하며 발생할 수 있는 여러 상황을 방지하고 원래 가리키는 객체를 지시하는 의미로 참조자를 이용해서 받는다.

### 소멸자 (파괴자)

파괴자 혹은 소멸자는 인스턴스가 사라지기 직전에 자동으로 호출되는 멤버함수이다. 인수가 없는 기본 생성자 명칭에 `~` 가 붙어있는 형태이며 힙 영역에 생성된 인스턴스일 경우엔 delete를 이용해서 지울 때, 스택 영역에 생성된 인스턴스인 경우엔 인스턴스를 생성한 함수가 종료될 때 호출된다.

### 할당 연산자 오버로딩

#### 오버로딩 (Overloading)

cpp00 에서 언급했듯이 OOP 언어의 세 가지 특징중 하나가 다형성 (Polymorphism) 이다. 한 가지의 프로그램 요소 (함수명, 연산자, 변수 등등등)가 여러 자료형에 속하거나 그것을 처리할 수 있는 것을 의미한다. 절차지향인 C에서 동일한 기능을 하지만 입력되는 인수의 자료형이 여러 가지인 함수를 만들 때를 생각해보자. 그런 경우 인수 자료형 개수만큼 함수명을 다 따로따로 지정해야 한다. 다형성을 지원하는 언어에서는 동일한 함수명에 다른 자료형에 대한 인수로 처리할 수 있다.

오버로딩은 동일한 클래스 내 동일한 이름을 가지고 있지만 인수 형태나 개수가 다른 메소드들을 만드는 것을 오버로딩이라고 한다. C++은 멤버함수 뿐만 아니라 연산자에 대해서도 오버로딩을 지원한다.

#### 연산자 오버로딩

비슷한 객체지향 언어인 자바와는 다르게 C++은 연산자에 대해서도 오버로딩을 지원한다. 오버로딩은 함수로 구현하며 기존에 존재하는 연산자로만 구현해야 한다. 일부 오버로딩이 불가한 연산자도 있지만 일반적인 산술 연산자 등은 오버로딩이 가능하다.

자연스러운 산술 연산을 할 때 (예를 들어 정수형과 실수형을 덧뺄셈할 때) 적절하게 상황에 맞게 형변환이 되어서 연산이 되지만 아예 다른 타입에 대해 연산을 하거나 임의로 지정한 타입에 대해 연산을 할 때에 대해선 연산자 오버로딩을 해야 한다.

#### 할당 연산자 오버로딩과 복사 생성자

인스턴스를 생성할 때 대입 연산자를 사용하면 복사 생성자가 호출된다. 하지만 그 이외에 상황에서 대입 연산자를 사용하면 할당 연산자가 호출된다. 할당 연산자에 대한 동작을 별도로 선언하지 않았을 때에는 알아서 멤버 변수들을 복사해 주나 역시 내부 변수가 포인터가 있을 때에는 깊은 복사를 해야 하므로 이런 경우에도 복사 생성자를 별도로 정의하여야 한다.

## ex00

### 제출 파일

- Fixed.class.hpp or Fixed.hpp
- Fixed.class.cpp or Fixed.cpp

C++의 실수형 자료형은 부동 소수점 (IEEE 754) 형식으로 표현된다. 부동 소수점은 한정된 비트로 넓은 범위의 실수를 표현할 수 있는 장점이 있지만 특성상 오차가 존재할 수 밖에 없다.

이번 과제는 고정 소수점 자료형 (타입/클래스)을 구현하기 위해 클래스의 뼈대를 만들며 예시로 주어진 코드와 출력대로 동작되게 하는 과제이다.

클래스는 캐노니컬 폼을 따르게 선언해야 한다.

#### 멤버 변수

- 정수 (고정 소수점 값이 저장되는 공간)
- 정적 변수이자 상수인 정수 (8)

#### 멤버 함수

- 기본 생성자
- 파괴자
- 복사 생성자
- 할당 연산자 오버로딩
- getRawBits(void) const (멤버변수인 정수를 리턴해 준다.)
- setRawBits(int const raw) (정수에 해당 값을 셋 해준다.)

### 학습해야 하는 내용

- 생성자와 파괴자
- 복사 생성자
- 할당(대입) 연산자 오버로딩

### 할당(대입) 연산자 오버로딩

연산자의 오버로딩은 연산자의 특성에 따라 입력 인수, 반환 타입, 상수 함수의 여부 등을 신경써야 한다. 연산자에 특성에 따라 적절하게 이 항목들을 신경쓰지 않으면 느려지거나 오류가 발생할 수 있으므로 연산자의 특성을 잘 파악한 후 할당하여야 한다.

할당 연산자의 오버로딩을 예로 연산자의 오버로딩 및 할당 연산자를 오버로딩할 때 주의할 점을 알아보자.

연산자의 오버로딩 선언 형식은 다음과 같다.

```c++
[반환 형식] ClassName::operator[연산자] ([인수])
```

형태를 보면 일반 멤버함수와 형식이 함수 이름 빼고 동일한 것을 볼 수 있다. 그래서 결국 C++에선 다음이 동일하다.

```c++
A [연산자] B
A.opreator[연산자](B)
```

둘이 완전히 동일한 의미이며 할당 연산자 같은 경우는 클래스를 생성할 때 내부적으로 디폴트 할당 연산자가 생성이 되므로 임의의 객체에 대해서 할당 연산자를 쓸 때 다음과 같이 작성해도 동작 자체는 한다. (그래서 할당 연산자의 경우 깊은 복사나 여러 처리가 필요할 경우에 보통 오버로딩을 지정한다.)

```c++
ClassName A();
ClassName B;
A = B;
A.opreator=(B);
```

#### 할당 연산자의 반환형식

C++에선 할당 연산자는 보통 결과값을 리턴한다. 정확히 말하면 값이 할당되고 나서 좌변 그 자체를 리턴하게 동작한다. 그래서 반환 형식은 ClassName이어야 하며 좌변 값 그 자체를 의미하므로 레퍼런스를 반환한다. 따라서 반환 형식은

```c++
ClassName& ClassName::operator= ([인수])
```

가 된다.

내부 구현은 `this` 포인터를 이용해 본인(좌변) 객체에 접근해서 값을 변경하고 리턴도 본인 스스로를 하게 해야 한다.

#### 할당 연산자의 인수

인수가 포인터나 레퍼런스 타입이 아닌 경우 새로운 객체가 지역변수에 할당이 된다. (인수도 결국 지역변수이기 때문이다.) 이렇게 사용하면 속도 면에서 불리하게 되므로 포인터나 레퍼런스 타입을 이용해야 한다. 하지만 포인터 타입을 사용하면 우변에 항상 포인터 형을 삽입헤야 하기 때문에 레퍼런스 타입을 인수로 받아야 한다.

입력 인수는 변경하지 않을 것이기 때문에 const 형식으로 받는다. 따라서 인수 형식은

```c++
ClassName& ClassName::operator= (const ClassName& classname)
```

으로 쓴다.

#### 할당 연산자 함수의 내부 구현

대입 연산자를 사용할 때 좌변과 우변이 동일한 객체를 가리킬 때에 대해서도 생각해야 한다.

## ex01

### 제출 파일

- Fixed.class.hpp or Fixed.hpp
- Fixed.class.cpp or Fixed.cpp

클래스가 고정 소수점 형식으로 동작하기 위해 위의 클래스를 완성한다.

- 생성자는 상수 정수를 파라미터로 받으며 내부에서 고정 소수점으로 변환한다.
- 생성자는 상수 실수 자료형 (float)을 파라미터로 받으며 내부에서 고정 소수점으로 변환한다.
- 멤버함수 `float toFloat(void) const` 는 고정 소수점 값을 부동 소수점 값으로 변환하여 리턴한다.
- 멤버함수 `int toInt(void) const` 는 고정 소수점 값을 정수형으로 변환하여 리턴한다.
- `<<` 연산자에 대해 오버로딩이 필요하다. 출력 스트림에 대해 부동 소수점이 출력되도록 해야 한다.

사용 가능 함수/헤더 : `roundf (from <cmath>)`

### 학습해야 하는 내용

- 전역 연산자 오버로딩
- IEEE 754 표준 (부동 소수점)

### 전역 연산자 오버로딩

연산자의 오버로딩은 전역 함수로 만들 수도 있다. 이런 경우엔 클래스에 속한 형태가 아니기 때문에 입력 인수가 두개가 된다.

전역 연산자의 오버로딩 선언 형식은 다음과 같다.

```c++
[반환 형식] ClassName::operator[연산자] ([인수 A], [인수 B])
```

여기서는 `<<` 연산자에 대해 오버로딩을 한다. std::cout 에 대해 인수 B가 float 형으로 << 연산자로 들어가야 한다.

문제에서 주어진 조건은 다음과 같은 코드가 동작되도록 하는 것이다.

```c++
Fixed const b(1.234);
std::cout << "d is " << d << std::endl;
```

위 코드는 동작하지 않을 것이다. std::cout에 대해 << 연산자는 우변의 값이 문자열, 정수, 실수, 문자 등일 때 알아서 출력하도록 오버로딩 되어 있다. 하지만 d는 std::cout의 << 연산자에 대해 오버로딩되지 않은 객체이므로 별도로 오버로딩 해야 하며 d.toFloat()가 오도록 하게 해야 한다.

위 코드는 이맇게 동작된다.

```c++
Fixed const b(1.234);
((std::cout << "d is " ) << d) << std::endl;
```

코드를 보면 연산자 우변에 있는 값이 좌변에 대해서 무엇인가를 수행하고 그 결과가 반환되는 식으로 동작되는 것을 볼 수 있다.

그래서 연산자의 리턴값과 연산자 좌변 값은 같아야 하며 둘 다 참조형이어야 한다. 우변은 연산 내부에서 값을 변경하지 않으므로 const로 받는다.

여기서 주의해야 할 점은 std::cout은 std::ostream라는 클래스의 인스턴스이다. 따라서 형식은 std::cout가 아니라 std::ostream 으로 지정해야 한다.

지정하면 다음과 같다.

```c++
std::ostream &operator<<(std::ostream &out, const Fixed &fixed)
{
    out << fixed.toFloat();
    return (out);
}
```

### IEEE 754 표준

부동 소수점은 부호, 지수, 가수 3가지 요소로 나누어져 있다. 또 IEEE 754는 양의 무한, 음의 무한, 수가 아님 세가지 특수한 값이 별도로 존재한다. (이번 과제에서 고려할 대상은 아니다.)

부호는 수의 양수 혹은 음수를 나타내며 지수는 해당 수를 2진인 소수로 나타낼 때 수가 2 미만이 되도록 가수에 곱해지는 2의 n승을 의미하며 가수는 실제 수를 나타낸다.

중요한 부분도 많고 설명해야 하는 부분도 많지만 다른 참조를 찾아보는게 더 도움이 될 것이고 여기서 중요한 점은 가수부의 소수점 밑의 수도 2진법으로 표현되기 때문에 정확하게 10진법으로 변환할 수 없는 점이다.

이 과제에서 고정 소수점 형식은 소수점 비트 공간을 8비트 까지만 정확하게 저장한다.

https://inst.eecs.berkeley.edu//~cs61c/sp06/handout/fixedpt.html 페이지를 참조하여 쉬프트 연산 등을 이용해서 구현하면 된다.