# 스택 구현 및 스택 내의 데이터 정렬하기 (push_swap)

## 스택

스택은 데이터를 다루기 위한 추상적인 자료 구조이다. (이런 것들을 추상 자료형, Abstruct Data Type이라고 한다.) **스택** 이라는 말에서 드러나듯이 스택은 말 그대로 데이터를 쌓는 것을 의미한다.

데이터를 쌓게 되면 맨 밑의 데이터부터 한 층씩 데이터가 맨 위의 데이터까지 쌓여 있는 것을 연상할 수 있다. (실제로 데이터가 쌓여 있는 것은 아니고 쌓여 있는 것처럼 생각하는 것이다. 스택은 데이터를 잘 다루기 위한 추상화 자료형이라는 것을 상기하자.)

### 주요 연산

스택에는 아주 기본적인 연산 두 가지가 존재한다.

- PUSH : 스택에 데이터를 추가함. 데이터는 맨 위 데이터 위에 한 층이 쌓임.
- POP : 스택에서 데이터를 뽑아냄. 데이터는 맨 위 데이터가 뽑힘.

그 외 보조하기 위한 여러 연산들이 존재하나 저 두 가지 연산이 가장 핵심이다.

## push_swap

push_swap은 간단하고(연산이 적고) 효율이 좋은 (시간복잡도가 낮은) 정렬을 구현하는 과제이다.

push_swap에는 두 개의 프로그램을 만들어야 한다.

1. checker

   정수 인자들을 인수로 받아 표준 입력으로 정렬 연산 명령어를 읽는다.

   checker는 정수들이 정렬되었으면 OK를 출력하고 정렬되어있지 않으면 KO를 출력한다.

2. push_swap

   정수 인자들을 입수로 받아 가장 적은 수의 연산을 사용해 받은 정수 인자들을 정렬하는 정렬 연산 명령어를 출력한다.

push_swap은 이 과제에서 사용되는 스택 관련 전용 연산이 존재한다. 이 연산을 이용해서 스택을 구현하고 정렬하는 과제이다.

쉴게 설명하면 push_swap에서는 정렬되지 않은 숫자 배열을 받아 이를 스택화 하여 이를 정렬시킬 수 있는 최적의 알고리즘을 통해 주어진 스택 연산으로 정렬할 수 있도록 한다. 이 연산들은 표준 출력으로 출력한다.

checker는 인수로 숫자 배열을 받고 표준 입력으로 이를 정렬하는 스택 연산을 받아 이 연산대로 스택이 정렬이 되면 OK, 정렬이 되지 않으면 KO를 출력한다.

### push_swap의 스택 연산

push_swap에 사용되는 스택 연산(명령어)이 존재한다.

push_swap에서는 스택을 두 개 사용하며 각각 a, b라고 부른다. 또 a에는 정렬되지 않은 정수가 들어있고 b는 비어있다.

스택 연산들을 적절히 사용하여 a에 들어있는 원소들을 오름차 순으로 정렬한다.

- sa : swap a - a스택의 맨 위 (top)의 두 개의 원소의 위치를 바꾼다. 만약 스택에 1개 이하의 원소밖에 없다면 수행하지 않는다.
- sb : swap b - b스택의 맨 위 (top)의 두 개의 원소의 위치를 바꾼다. 만약 스택에 1개 이하의 원소밖에 없다면 수행하지 않는다.
- ss : sa와 sb를 동시에 수행한다.
- pa : push a - b의 맨 위 (top)의 하나의 원소를 pop 하여 a에 push한다. b에 원소가 없다면 수행하지 않는다.
- pb : push b - a의 맨 위 (top)의 하나의 원소를 pop 하여 b에 push한다. b에 원소가 없다면 수행하지 않는다.
- ra : rotate a - a의 맨 위 (top)에 있는 하나의 원소를 맨 밑 (bottom) 으로 집어넣는다.
- rb : rotateb - b의 맨 위 (top)에 있는 하나의 원소를 맨 밑 (bottom) 으로 집어넣는다.
- rr : ra와 rb를 동시에 실행한다.
- rra : reverse rotate a - a의 맨 밑 (bottom)에 있는 하나의 원소를 맨 위 (top)로 집어넣는다.
- rrb : reverse rotate b - b의 맨 밑 (bottom)에 있는 하나의 원소를 맨 위 (top)로 집어넣는다.
- rrr : rra와 rrb를 동시에 실행한다.

## push_swap 과제 해결 흐름

개인차가 있겠지만 나는 다음과 같이 전략을 세웠다.

1. 스택 구현과 스택 연산 구현
2. checker 프로그램 구현
3. push_swap 구현
   1. 정렬 알고리즘 구현

가장 먼저 스택 및 관련 연산부터 구현해본다.

## 스택/연산 구현

### 스택

스택을 구현할 수 있는 방식은 여러 가지가 있다. 배열에 주욱 나열해도 되고 링크드 리스트를 사용해도 된다. 배열을 사용하면 링크드 리스트를 구현할 필요가 없는 장점이 있지만 배열 크기를 동적으로 관리하여야 하며 push/pop 연산 시 어느 부분을 가리키는지 기록을 해 놓아야 한다. 또 단순히 메모리에 나열하는 식으로 구현하고 push/pop 연산을 반복하면 메모리 참조 인덱스가 올라가 오류가 날 수 있다.

따라서 단순히 배열을 통해 구현할 거면 이런 부분에 대한 구현이 필요하다. (이런 경우 보통 원형 큐 형태로로 구현한다.)

하지만 링크드 리스트를 이용하면 push/pop 할 때에만 그 원소에 대해서 동적으로 할당/해제하면 되고 이전에 링크드 리스트를 구현한 과제를 가져다 사용해도 되기 때문에 링크드 리스트로 구현한다.

### 스택 연산

스택 연산 중 스택에 없는 (스택 기본 연산으로 구현할 수 없는) rotate 연산이 있다. 이 연산은 맨 밑에 있는 원소를 뽑아야 하는데 push/pop 만으로만 구현하려면 불필요한 연산을 많이 하게 되므로 이 부분에 대해선 queue 형태로 구현한다.