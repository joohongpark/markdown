# C++ 입문 #3 (C++ Module 03)

이번 모듈에서는 OOP의 3가지 특징 중 하나인 상속을 C++에서 구현해 본다.

상속이란 기존 객체의 기능과 속성을 다른 객체에게 물려 주는 것을 의미하며 이런 기능이 있는 이유는 기존에 존재하는 객체와 비슷한 형질을 가진 객체를 만들 때 처음부터 새로 만드는 수고스러움을 덜기 위함이다.

이 과제에서도 당연히 캐노니컬 폼을 따라야 한다.

## 학습해야 하는 내용 - 상속

프로그래밍에서 상속은 자식에게 부모의 특성을 물려주는 것을 말한다. 하나의 특성을 공유하는 여러 클래스를 만들고자 할 때 유용하게 사용한다.

보통 프로그래밍에서의 상속은 부모 : 자식에서 끝나지 않으며 상속은 줄줄히 이어질 수 있다. 실제 가계도처럼 계층이 있을 수 있으며 트리와 비슷하게 생겼다. 실제 가문 가계도를 연상하면 동일하다.

참고로 자바에서는 `Object` 라는 클래스가 모든 클래스의 조상 클래스이다.

### protected 접근 제어자

protected 접근 제어자는 상속을 위해 private 대신 사용하는 접근 제어자이다. private로 지정된 변수나 함수는 자식 클래스에서도 접근이 불가능하다. 자식 클래스에서 접근이 필요하지만 외부에서 접근하지 못하게 하는 성질을 유지하고 싶으면 protected 접근 제어자를 사용하면 된다.

### 상속 지정

자식클래스를 선언할 때 `class 자식클래스 : 접근제어자 부모클래스` 와 같이 선언한다. 상속을 지정할 때에도 접근제어자가 올 수 있는데 이는 부모 클래스로부터 클래스 내부 요소들의 특성을 물려받을 때 어느 속성을 어떻게 물려받을지를 지정하는 것이다.

보통 public을 많이 사용하며 이런 경우 그대로 내부 속성을 물려받게 된다.

### 상속 지정자의 접근 제어자

상속 지정자에 붙어있는 접근 제어자는 부모 클래스의 멤버의 접근 권한을 나타낸다. 보통 public으로 많이 사용한다. 하지만 해당 부분에 대해서도 공부할 필요는 있다.

### 상속은 Is-a 관계이다.

객체지향에서 Is-a 관계이냐 Has-a 관계이냐 라는 용어를 종종 사용한다. 이 관계를 말 그대로 형질을 물려받은 부모-자식 관계인지 단순히 포함되어 있는 관계인지를 나타낸다.

예를 들어 human이라는 부모 클래스가 있고 man 이라는 자식 클래스가 있다면 논리적으로 man is a human이라는 문장이 성립한다. (당연히 역은 성립하지 않는다.) 하지만 동일하게 man has a human은 논리적으로 어섹함을 느낄 수 있다.

has-a는 클래스가 단순히 다른 클래스를 멤버로 추가하는 관계를 나타낸다. 예를 들어 human 이라는 클래스에 smartphone 이라는 클래스를 포함하고 있다면 human has a smartphone 이라는 문장은 논리적으로 아무 문제가 없다. (이것도 역은 성립하지 않는다.)

### 오버라이딩

오버라이드 (override)의 사전적인 뜻은 무시하다, 기각하다 와 같은 뜻을 가지고 있다. OOP의 다형성을 구현하기 위해 클래스의 상속에서 멤버함수 (혹은 메소드라고 칭하는)에 대해 오버라이딩이라는 것을 지원한다.

오버라이딩은 기존 부모 클래스에 동일한 시그니쳐(함수명이라 생각하면 된다)를 가지고, 입력 인자 개수와 형질도 동일한 멤버 함수를 재정의 할 때 필요하다. 부모가 가진 기능을 변형하고자 하는 것이다.

아마 부모의 멤버변수를 오버라이드 한다 라는 의미로 오버라이드라는 용어를 쓰는 것 같다.

### 오버라이딩 시 기존 부모 클래스의 멤버함수 접근

기존 부모 클래스가 가지고 있는 함수를 완전히 재정의하고자 하는 것이 아니고 기능만 추가하고자 할 때는 기존 멤버함수를 호출시키면 편할 것이다. C++에선 범위 지정 연산자 (`::`)를 사용해 오버라이딩 하는 함수 내에서 `부모클래스::함수()` 와 같이 호출하여 사용한다. (참고로 자바에서는 super 라는 클래스를 사용해 부모클래스의 메소드에 접근할 수 있게 해준다.)

### 다중 상속

다중 상속은 여러 클래스로부터 상속받을 때 사용한다. 선언할 때 `class 자식클래스 : 접근제어자1 부모클래스1, 접근제어자2 부모클래스2, ...` 와 같이 선언하고 사용하면 된다.

### 부모가 같은 클래스로부터 다중 상속

부모가 같은 클래스로부터 다중 상속을 받을 경우 문제가 된다. 왜냐 하면 이렇게 선언해 두고 호출하면 동일한 부모클래스의 생성자도 여러번 호출되며 동일한 명칭을 가진 변수가 충돌할 수도 있다. (범위 지정 연산자를 사용해 명시를 하거나) 이렇게 상속해 사용하는 것은 모호함과 충돌 등의 문제가 있으므로 잘 사용하진 않는다. (하지만 이 과제 마지막 문제에서 그렇게 상속해 쓴다. 참고로 자바에선 클래스에 대한 다중상속 자체가 안된다.)

### 가상 상속 (Virtual Inheritance)

부모가 같은 클래스로부터 상속을 받아 사용할 때 중복되는 생성자, 변수 등을 해결할 수 있다. 가상 ("Virtual") 키워드를 사용하면 되는데 공통된 부모로부터 파생된 클래스들을 선언할 때 `class 부모클래스 : virtual 접근제어자 조상클래스` 와 같이 선언하면 된다. 이러한 것을 가상 기저 클래스 (Virtual Base Class) 라고 한다.

이렇게 하면 조상클래스의 중복되는 생성자, 인수들이 없어지는 효과가 발생한다. 하지만 내부적으로는 실제로 없애는 것처럼 동작하기 위해 다소 비효율적인 동작을 한다. 임의로 vbptr (일반적인 호칭임)이라는 포인터를 따로 만들어 관리하게 되므로 실제로는 동작 속도 및 메모리 공간을 비효율적으로 사용한다. 그래서 부모를 공유하는 다중 상속을 애초에 잘 사용하지 않는다. 불이익에 대한 자세한 내용은 따로 검색.

### 업캐스팅과 다운캐스팅

부모 클래스가 자식 클래스를 받을 수 있을까? 혹은 가리킬 수 있을까? 만약 자식 클래스로부터 객체가 생성되고 이를 바탕으로 부모 클래스를 복사연산자와 같은거로 새로 생성하면 정상적으로 내부 값이 복사가 될까? 답은 가능하다. 이러한 것을 통틀어 업캐스팅 (upcasting) 이라고 한다. 업캐스팅이 가능한 이유는 논리적으로 생각하면 당연하다. 자식이 가지고 있는 요소는 모두 부모가 가지고 있다.

반대는 다운캐스팅이라고 한다. 이런 경우 명시적으로 형변환 연산자를 사용하지 않으면 다운캐스팅은 금지되어 있다. 왜냐 하면 부모에 없는 요소에 대해 정의된 것이 없기 때문에 어떤 예외 상황이 발생할 지 모르기 때문이다.

## ex00

### 제출 파일

- FragTrap.cpp
- FragTrap.hpp
- main.cpp

FR4G-TP와 비슷한 클래스(FragTrap)를 만들라고 한다. 참고로 FR4G-TP는 보더랜드라는 게임(정확히 말하면 보더랜드 프리시퀄)에 나오는 로봇 이름이다.

FragTrap 클래스는 다음 속성과 초기값을 가지고 있다,

- Hit points (100)
- Max hit point (100)
- Energy points (100)
- Max energy point (100)
- Level (1)
- Name (생성자 파라미터)
- Melee attack damage (30)
- Ranged attack damage (20)
- Armor damage reduction (5)

멤버 함수는 다음과 같다.

- rangedAttack(std::string const & target)
- meleeAttack(std::string const & target)
- takeDamage(unsigned int amount)
- beRepaired(unsigned int amount)
- vaulthunter_dot_exe(std::string const & target)

위 함수들은 호출될 때 관련 내용을 출력해야 한다. 예를 들면 rangedAttack 과 같은 멤버함수는

`FR4G-TP <name> attacks <target> at range, causing <damage> points of damage!` 와 같은 라인을 출력해야 한다.

클래스의 생성자와 파괴자는 실행될 때 무엇인가를 화면에 출력해야 하며 FR4P-TP 라는 로봇에 맞게 재미 요소를 추가해 보아라.

지켜져야 할 점은

- Energy point, Hit Point는 최대값을 넘어서는 안되며 0 밑으로는 떨어지면 안된다.
- 데미지를 받으면 armor 데미지가 감소되어야 함.
- vaulthunter_dot_exe 함수는 최소 5개 이상의 공격 풀에서 무작위로 하나를 집어 공격한다. 이 기술은 에너지가 25 이상일때만 발동 가능하며 25 미만이라면 에너지가 부족하다는 상태를 출력한다. (당연히 공격 풀 - 함수들은 따로 만들어야 한다.)

참고로 hit point = health point (HP) 이다... energy point는 랜덤기술을 발동하기 위해 필요한 에너지이다... 어떻게 연관시킬지는 자유이다.

## ex01

### 제출 파일

- FragTrap.cpp
- FragTrap.hpp
- ScavTrap.cpp
- ScavTrap.hpp
- main.cpp

이전 프로젝트에서 ScavTrap (FragTrap과 비슷한 캐릭터임) 클래스도 만들어서 추가해보자. 위 캐릭터 클래스와 다른점은

1. 초기화 값
2. 필수 함수 중 1가지 변경

이다.

## ex02

### 제출 파일

- FragTrap.cpp
- FragTrap.hpp
- ScavTrap.cpp
- ScavTrap.hpp
- ClapTrap.cpp
- ClapTrap.hpp
- main.cpp

공통된 속성을 가진 ClapTrap을 만들고 이전에 만들었던 Trap 로봇들은 이로부터 상속받은 형태로 리팩토링해라.

## ex03

### 제출 파일

- FragTrap.cpp
- FragTrap.hpp
- ScavTrap.cpp
- ScavTrap.hpp
- ClapTrap.cpp
- ClapTrap.hpp
- NinjaTrap.cpp
- NinjaTrap.hpp
- main.cpp

이전 코드를 바탕으로 NinjaTrap 클래스를 만들고 NinjaTrap 멤버 함수로 ninjaShoeBox 함수를 만들어라. ninjaShoeBox는 동일한 시그니처를 가진 여러 개의 함수로 구성된다. 함수들의 입력은 각각 객체에 따라 다른 레퍼런스 타입으로 받으며 각각 다른 적절한 액션을 취한다. NinjaTrap 형식에 대한 액션도 별도로 만들어야 한다.

### 학습해야 하는 내용

- 오버로딩

### 오버로딩

OOP의 가장 큰 3가지 특징 중 한가지인 다형성을 지원하기 위해 동일한 ㅎ