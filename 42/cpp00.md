# C++ 입문 #0 (C++ Module 00)



C++ 모듈들은 C++에 대해 중요한 개념을 학습할 수 있도록 해준다. 이 모듈 과제들을 수행하며 객체지향의 기초와 C++의 문법 등을 학습하게 된다.

## C++

비야네 스트롭스트룹이라는 덴마크 사람이 만들었다. 현재 모건 스탠리에서 근무중이며 (https://www.morganstanley.com/profiles/bjarne-stroustrup-managing-director-technology) C에 객체지향성을 덧붙힌 확장팩같은 개념으로 만들어서 C 코드가 C++ 문법에 호완되었지만 현재는 별도로 분리되었다. 하지만 C에서 지원하는 많은 부분을 C++에서 그대로 지원한다.

절차지향인 기계어에 가까운 C와 추상적인 객체지향 언어를 호환하기 위해서 지원하는 기능도 많으며 (요즘엔 함수형 프로그래밍도 지원한다...) 그런 유연함 때문에 복잡하다. 그래서 가장 이해하기 어려운 언어로 손꼽히는 언어이다. 자유도가 높은 게임일수록 게임에서 할 수 있는 행동이 많은 것과 유사할까?

C++은 실행 성능이 중요한 분야에 주로 사용된다. (게임, PC에서 구동되는 브라우저나 포토샵 등과 같은 프로그램들) 또 웹 분야에서는 잘 사용되지 않으며 어플리케이션도 주로 자바(코틀린)나 swift를 이용해서 개발하므로 앱개발 분야에서도 잘 사용하지 않는다. (백앤드에서 구동되는 nginx나 아파치 서버 자체는 c나 자바로 만든다... 그 위에서 구동되는 웹앱 백앤드단은 자바나 파이썬 루비 등을 사용한다...)

객체지향 형태로 프로그램을 작성하고자 할 때 아주 빠르게 구동되게 하고 싶다면 주로 C++를 이용한다.

C++은 보통 `[씨 플러스 플러스]` 라고 발음한다.

## c++ 공통 룰

1. 확장자는 *.cpp, *.hpp임.
2. 보호된 헤더를 사용해야 하며 헤더 안에서 함수 기능 구현하지 말 것
3. 모든 출력은 표준 출력으로 출력되며 끝에 개행을 붙여야 함. (특별한 경우 제외)
4. 파일 이름은 클래스/함수/메소드 이름으로 짓는다. 알파벳 문자로만 짓는걸로 제한하는 듯.
5. 클래스 코드와 헤더파일은 클래스 명으로 지음
6. malloc / free / printf 같이 C스러운 함수 사용하지 말 것
7. 표준 라이브러리에 있는 것들을 사용하며 과제에서 허용되는 경우가 아닌 경우 STL은 사용하지 말 것
8. c++ 키워드인 "using namespace" 및 "friend" 사용하지 말 것
9. 명시적으로 금지된 기능은 절대 사용하지 말 것
10. 의도적으로 명확하게 요구사항을 안 적어놓은 것들이 있는데 이는 C++을 이해하면 명확해짐.
11. 컴파일러는 clang++ 을 이용해서 컴파일한다.
12. -Wall -Wextra -Werror 플래그 사용
13. 각각의 include는 그 include가 의존하는 것들을 포함해야 함.
14. norminette 적용되지 않음.
15. 제출할 때 불필요한 파일이 포함되는걸 제한하진 않는다.

## 공통 룰 해설

1. C++에서 사용하는 소스파일과 헤더파일 확장자이다.
2. 헤더를 "보호" 하라는 말은 #ifndef #define~#endif 를 써서 헤더파일이 중복포함되는 것을 방지하라는 의미이다. (이를 Include Guard 라고 함)
3. 말그대로임
4. 클래스/함수/메소드 단위로 코드를 분리할 때 이 분리된 파일 혹은 헤더명을 이거로 지으라는 의미. "letter" 라고 표현되어 있는데 알파벳만 써서 명명하라는 의미로 보임.
5. 4번과 동일
6. malloc/free를 사용하지 말라는 의미. printf 대신 cout 사용
7. 표준 라이브러리는 "C++ 표준 라이브러리"를 의미하고 STL은 "표준 템플릿 라이브러리(STL: Standard Template Library)" 를 의미한다. STL은 큐, 스택, 벡터, 덱 등과 같은 객체들을 지원해 준다. 이런것(STL)들은 문제에서 명시하지 않는 이상 사용하면 안된다.
8. namespace 란 개체나 라이브러리를 해당 공간에서 사용할 수 있는 범위를 지정하는 개념이자 C++의 키워드이다. 무슨 말이냐면 c++ 코드 기반 프로젝트가 std 라는 라이브러리에 cout을 사용한다면 `using namespace std` 혹은 `using std::cout` 을 사용해서 명시할 수 있다. 네임스페이스를 사용한 전자는 std 내부의 모든 것을 다 가져다 쓸 수 있고 후자는 라이브러리에 cout만 가져다 사용한다. 네임스페이스의 무분별한 사용은 클래스/메소드/함수명 등의 충돌을 야기할 수 있으므로 사용을 지양해야 한다. friend는 클래스 내부에 private 요소를 다른 클래스에서 접근하게 해주는 키워드이다.
9. 말그대로임
10. 말그대로임
11. clang은 [클랭]이라고 발음한다.
12. 말그대로임
13. 말그대로임
14. 말그대로임
15. 말그대로임

## ex00

### 제출 파일

- Makefile
- megaphone.cpp

인수들을 표준 출력에 출력한다. 인수 내의 소문자들을 대문자로 변환해야 한다. 인수가 없으면 `* LOUD AND UNBEARABLE FEEDBACK NOISE *` 를 출력한다.

### 학습해야 할 내용

- cout
- 표준 헤더
- C++식 형변환
- endl

### C++ 표준 헤더

C++에서 사용되는 표준 라이브러리는 헤더에 .h를 붙이지 않는다. 예를 들면 `#include <iostream>` 은 입출력 스트림을 사용하기 위래 include하는 것이고 iostream은 표준 라이브러리이기 때문에 붙이지 않는다. 비표준 라이브러리나 사용자 정의 헤더는 확장자를 붙여야 한다. (자세히 알고싶으면 https://www.learncpp.com/cpp-tutorial/header-files/의 Why doesn’t iostream have a .h extension? 항목을 확인)

### std::cout

C++에서 표준 출력으로, C에서의 printf처럼 cout을 사용한다. 하지만 함수에 인수를 집어넣는 것과 같은 printf처럼 사용하지 않는다. 예를 보자.

```c++
#include <iostream>

int		main (int argc, char *argv[]) {
    std::cout << "hello c++" << std::endl;
    return (0);
}
```

printf("hello c++"); 처럼 쓸 거 같지만 형태가 전혀 다르다. C에서 비트 쉬프트 연산자로 사용하는 연산자가 들어가 있고 함수처럼 사용하는 것도 아닌거같다. 왜 이렇게 사용하는 것일까?

동작되는 개념만 설명하자면 `std::cout` 은 ostream 이라는 클래스의 객체이며 `<<` 연산자는 저 클래스 내에서 한정적으로 다른 기능으로 오버로딩 된 것이다. 실제로 `<<` 연산이 무엇을 하는지는 몰라도 cout 객체에 원하는 값을 지정해서 집어 넣을 수 있다.

연산자 오버로딩, 객체, 클래스 등은 추후 다른 과제에서 배우게 될 것이므로 생략한다. 일단 저렇게 사용하는 것만 알고 있으면 된다.

참고로 `::` 연산자는 scope resolution operator 라고 하며 간단하게 설명하면 A::B 라고 하면 A 요소의 B 요소에 접근하는 것을 의미한다. 아마 추후에 더 자세히 다룰 것이다.

### C++식 형변환 (타입캐스팅)

C++은 클래스와 같이 여러 가지 타입들을 지원함과 C에서의 명시적인 형변환의 단점을 보완하기 위해 여러 종류의 캐스팅 연산자들을 추가하였다. (기존 C스타일의 형변환도 사용 가능하지만 C++을 학습하는만큼 C++에서 제공하는 형변환을 사용해보자)

- `type(target)`
  - 가장 기본적인 캐스팅 연산
  - C style : (type)target / C++ style : type(target)

- `dynamic_cast<type>`
  - 상속 관계에 있는 객체의 포인터를 다른 객체 형식의 포인터로 안전하게 형변환 할 때 사용한다.
  - 객체의 포인터가 아닌 자료의 형식을 형변환할 때에도 사용한다.
  - 프로그램 실행 중 (런타임)에 타입 정보를 검사하여 동적으로 형변환한다. 이를 RTTI라 한다. 그래서 타입 캐스팅 에러를 잡을 수 있다.

- `static_cast<type>`
  - 상속 관계에 있는 객체의 포인터를 다른 객체 형식의 포인터로 위험성을 가지고 형변환 할 때 사용한다.
  - 객체의 포인터가 아닌 자료의 형식을 형변환할 때에도 사용한다.
  - 프로그램 컴파일 시에 적용되므로 잘못된 타입 캐스팅이 발생할 수 있다.
- `const_cast<type>`
  - 상수성을 주거나 뺄 수 있다.
  - 확실히 이해하고 사용하여야 한다. 자세한 설명은 생략
- `reinterpret_cast<type>`
  - 비트 단위로 형변환을 지원한다.
  - 정수를 정수 포인터형으로 변경하거나 할 수 있다.

여기서는 형변환에 대한 위험성도 없으므로 `static_cast<char>` 를 사용한다. 아니면 그냥 `char()` 로 써도 된다.

### std::endl

일반적인 운영체제에서 구동되는 프로세스에서 표준입출력에 무엇인가를 입력받고 출력하는 기능은 운영체제의 "버퍼"에 잠시 저장이 되었다가 프로세스로 들어가게 된다. 이렇게 하는 이유는 여러가지가 있겠지만 한 문장으로 압축해서 표현한다면 "데이터 전송을 보다 잘 하기 위해서" 일 것이다.

표준 입력은 보통 문자를 버퍼 내에 계속 받고 있다가 개행 문자나 eof가 입력되면 버퍼를 프로세스에게 전달한다.

표준 출력은 보통 개행 문자를 만나거나 출력 버퍼가 가득 차면 버퍼를 실제 표준출력에 출력되도록 한다.

위의 버퍼를 비우는 방식은 운영체제에서 기본으로 설정된 방식이며 실제 표준은 아니다. 그래서 c++에선 이런 모호함을 방지하기 위해 cout을 이용해서 표준 출력에 문자열을 작성할 때 std::endl를 이용해 개행 문자를 출력함과 동시에 버퍼를 비울 수 있도록 강제해 준다.

실제로 endl은 MacOS 내에선 다음과 같이 구현되어 있다.

```c++
__os.put(__os.widen('\n'));
__os.flush();
```

하지만 속도가 중요한 부분에서 std::endl를 사용하면 오버헤드가 발생할 수 있으므로 적절한 상황에서 사용해야 한다.

## ex01

### 제출 파일

- Makefile
- *.cpp
- *.hpp

전화번호부 프로그램을 만든다.

ADD, SEARCH, EXIT 명령어가 존재해야 한다. 다른 명령어는 무효함.

프로그램을 처음 시작하면 비어있어야 함.

동적 할당은 사용하면 안된다.

연락처는 다음 정보를 가지고 있어야 한다.

- first name
- last name
- nickname
- login
- postal address
- email address
- phone number
- birthday date
- favorite meal
- underwear color
- darkest secret.

전화번호 저장공간은 8개이며 8개일 때 ADD 하면 적당한 동작을 정의하고 적당한 조치를 취해라.

- EXIT : 프로그램 종료
- ADD
  - 정보를 입력받는 프롬프트를 이용해 정보를 입력받는다.
  - 연락처는 클래스의 객체로 이루어져야 한다.
- SEARCH
  - 존재하는 연락처를 인덱스 | first name | last name | nickname 으로 출력한다.
  - 각 컬럼은 10char의 길이를 가지게 출력되어야 한다. '|' 으로 항목들이 구분되며 오른쪽 정렬(항목들이 오른쪽에 붙어있어야 하며 왼쪽의 남는 공간은 공백으로 채움)되어야 한다. 출력할 문자열이 10char 이상이면 마지막 문자를 dot으로 치환해 거기까지만 출력한다.
  - 사용자가 원하는 인덱스를 입력받으면 그 연락처만 한 줄로 출력한다.
  - EXIT가 입력될 때까지 반복

### 학습해야 할 내용

- 객체지향 프로그래밍 (OOP)
- 클래스
- C++의 string 클래스

### OOP와 클래스

C와 C++의 가장 큰 차이점은 C++은 객체란 개념이 존재한다는 것이다. C 스타일의 코딩은 코드가 한줄한줄 순서 (명령어) 대로 동작되는 것처럼 보인다. 이를 절차지향 프로그래밍이라고 한다.

#### 절차지향

"절차 지향" 이기 때문에 여러 데이터들에 대해 단순히 연산하는 방식이므로 특정 데이터에 대한 고유의 연산이나 행동을 부여할 수 없다.

이런 방법은 코드가 단순하면 문제가 되지 않지만 기능이 복잡해지고 코드도 복잡해지면 가독성도 떨어지게 된다.

그리고 특정 자료에 대해 특정 기능을 하는 함수를 만든다 생각해보자. 이름, 나이, 성별 등의 정보를 가지고 있는 human이라는 구조체가 있다면 이 구조체에 접근하는 함수를 별도로 따로 만들어야 한다. 만드는 것보다 더 큰 문제는 기능을 하는 함수명이다.

만약 human 구조체의 내용을 출력하는 함수명이 print() 라면 이 함수명은 다른 함수명과 충돌할 수도 있다.

절차지향 언어는 이런저런 한계와 단점이 명확했으며 이를 보완하기 위해 객체 지향이라는 개념이 등장하였다.

#### 객체지향

OOP (Object-Oriented Programming)는 객체 지향 프로그래밍이라고도 한다. 말 그대로 코드의 구성 요소들을 고유한 "객체"로 분할하여 관리하자는 개념이다.

객체지향에서 "human" 속성을 가진 무엇인가를 만들고자 하면 "human" 이란 독립된 객체를 만들면 된다.

human 객체의 내용을 출력하는 함수를 만들고자 할 때에는 human.print() 와 같이 human에 종속된 함수로 만들 수 있다.

이런 식으로 구현하면 보기에도 좋고 개발하기도 좋다.

#### 객체지향의 특징

- 캡슐화
  - 특정 함수나 변수를 하나의 객체로 묶을 수 있는 것을 말한다.
  - 정보 은닉 : 외부로 공개하기 싫은 (외부에서 함부로 동작시키면 안된다던지) 변수나 함수를 감출 수 있다.
- 상속
  - 객체의 속성과 기능을 물려줄 수 있는 것을 의미한다. 객체를 새로 작성하지 않고 재사용할 수 있다.
    - 예를 들면 "human" 이라는 개체의 일부 속성을 차용하거나 새로 추가해 새로운 "man" 이라는 개체를 만들 수 있다.
  - 오버라이딩 (Overriding) 이라고 한다.
- 다형성
  - 상황에 따라 변수나 함수가 다르게 동작되는것을 의미한다.
    - C++은 연산자도 원래 기능과 다르게 동작시킬 수 있게 할 수 있다.

위 세가지 특징은 OOP의 3대 요소이며 객체지향 프로그래밍 언어라면 저 3가지 속성을 가지고 있어야 한다.

#### 디자인 패턴

객체지향 프로그래밍은 장점이 많은 프로그래밍 방법이다. 근데 절차지향으로 코딩하던 사람이 객체지향으로 코딩을 갑자기 하게 되면 객체지향스럽지 않게 코딩할 수 있다. 또 여러가지 문제를 코딩으로 구현하거나 해결할 때 비슷한 코딩 패턴이 존재할 수 있다.

객체지향 프로그래밍에서 많이 사용되는 코딩 패턴을 종류와 특징별로 분류시켜 둔 것을 디자인 패턴이라고 한다.

객체지향 프로그래밍을 할 때 디자인 패턴이 강제되지는 않지만 디자인 패턴을 사용하면 개발자들 간 소통이 수월해지며 어느 기능을 구현하고자 할 때 디자인 패턴을 사용하면 쉽게 구현할 수 있다.

가장 유명한 패턴은 GoF의 23가지 디자인 패턴이다.

#### 객체

객체는 상태(변수)와 행동(함수)을 가진 독립적인 집합을 의미한다. 현실세계에서도 상태와 행동을 가진걸 객체라고 부를 수 있다. 객체는 상태를 의미하는 멤버변수와 행동을 의미하는 멤버함수로 이루어져 있다. (참고로 자바에서는 멤버변수는 필드라고 부르고 멤버함수는 메소드라고 부른다.)

#### 클래스

클래스는 위에서 말한 "객체"의 설계도를 의미한다. 클래스로부터 객체를 생성할 수 있다.

#### 인스턴스

인스턴스는 클래스(설계도)로부터 생성된 고유한 객체를 의미한다. 예를 들어 실제 세계에서 동일한 설계도를 이용해 제품을 제작한다 해도 그 제품의 사용자의 성향이나 제조사의 성향에 따라 다른 제품이 나온다. 같은 클래스로 만들었지만 결국 각각의 객체로써 존재하는 것이다.

신규 인스턴스가 생성될 때 마다 그 인스턴스를 위한 공간을 클래스로부터 생성하여 메모리에 신규로 할당하여 준다.

객체 중 클래스로부터 생성된 객체를 인스턴스라고 부른다.

### 	C++의 클래스

C++의 클래스는 멤버 변수와 멤버 함수로 이루어질 수 있는 일종의 타입이다. 타입이기 때문에 기존 변수나 구조체와 유사하게 사용할 수 있다.

#### 예제

```c++
#include <iostream>

class Human {
	private:
		int age;
	public:
		void setAge(int Age) {
			age = Age;
		}
		int getAge(void) {
			return (age);
		}
		void plusAge(void) {
			age++;
		}
};

int	main(void)
{
	Human p;
	p.setAge(1234);
	std::cout << p.getAge() << std::endl;
	p.plusAge();
	std::cout << p.getAge() << std::endl;
	return (0);
}
```

클래스의 정의는 일반적으로 위와 같다. class [클래스명] {선언내용}; 틀을 따르며 선언 내용은 접근 제한자 (private: / public:)와 멤버 변수, 멤버 함수로 이루어진다.

클래스의 정의는 객체에 대한 규격을 정의하는 것이며 메모리를 할당하지 않는다. 클래스를 사용하려면 메모리를 할당해야 하며 메모리를 할당하는 방법은 인스턴스 (객체)를 생성하는 것이다.

위 main문에 있는 `Human p;` 코드는 Human 클래스 객체를 메모리에 할당하게 해 준다. 이런 경우 일반적인 구조체나 지역변수와 동일하게 스택 영역에 할당된다.

생성된 객체의 요소 (멤버변수나 멤버함수)에 접근할 때에는 dot 연산자를 이용해서 접근한다.

(new 연산자를 이용해 클래스로부터 인스턴스를 생성해야 메모리에 할당이 되어 사용 가능한 자바와는 좀 다르다.)

#### 접근 제어자

접근 제어자는 OOP의 세 가지 요소인 캡슐화에 속하는 정보 은닉을 위한 것이다. 클래스 외부에 노출시키면 안되는 멤버 변수나 멤버 함수를 감출 필요가 있다. 정보 은닉을 위해 접근 제어자를 사용한다.

C++에는 세 가지의 접근 제어자가 존재한다. (비슷한 OOP 언어인 자바에는 4가지가 존재한다.)

- Private
  - 클래스 외부에서 접근하지 못하는 요소이다. 해당 클래스로부터 상속받은 클래스에서도 접근하지 못한다. 외부에서 클래스에 dot 연산자로 접근하지 못하게 막을 수 있으며 오직 클래스 내부의 멤버 함수 혹은 friend 키워드를 이용한 특수한 상황에서만 접근 가능하다.
  - 클래스에서 접근 제어자를 붙이지 않으면 private한 요소가 된다.
  - 자바의 Private 접근 제어자와 유사하다.
- Public
  - 해당 클래스 내부/외부, 상속받은 클래스 등 아무데서나 접근 가능하게 하는 접근 제어자이다.
  - 자바의 Public 접근 제어자와 유사하다.
- Protected
  - 외부에서는 접근하지 못하지만 클래스 본인과 자식 클래스에서는 접근이 가능하다.
  - 자바의 Protected 접근 제어자와 유사하다.

#### C++에서 클래스와 구조체

위 클래스 선언문에서 class를 struct를 바꿔도 동일하게 동작된다. 내부적으로 정확히 어떤 차이로 구동되는지 아직 찾아보진 않았지만 사용하는 관점에서 가장 큰 차이점은 접근 제어자를 붙이지 않을 때 클래스에서는 private한 요소가 되며 구조체에서는 public 한 요소가 된다.

#### h와 hpp

C++에선 h나 hpp 파일 모두 헤더파일로 인식한다. hpp를 사용하는 이유는 C++ 헤더파일임을 구분하기 위해서 사용하는데 C++에선 함수나 클래스의 멤버함수의 기능 구현을 헤더파일 내에서 할 수 있다. 하지만 이렇게 하면 유지보수 할때에도 헷갈리고 현재 과제에도 금지되어 있으므로 멤버함수의 기능구현은 cpp 파일 내에 한다.

#### 클래스 멤버함수를 외부에서 정의하는 법

```c++
class Human {
	private:
		int age;
	public:
		int getAge(void);
		void plusAge(void);
		void setAge(int Age);
};

int Human::getAge(void) {
	return (age);
}
void Human::plusAge(void) {
	age++;
}
void Human::setAge(int Age) {
	age = Age;
}
```

클래스 내부에서 함수의 프로토타입만 선언하고 클래스 외부에서 scope resolution operator (::) 를 이용해 함수의 내용을 정의한다.

#### 생성자와 소멸자

클래스의 인스턴스를 생성하면 클래스 멤버변수에는 쓰레기값만 들어가 있다. 타이밍에 따라 다를 수 있지만 클래스의 쓰레기값은 불필요하며 오류를 야기할 수 있다. 그래서 클래스의 인스턴스를 생성하는 타이밍에 멤버변수들을 set 할 수 있다. 이는 C++에서 생성자로 지원한다.

생성자와 일반 함수의 겉보기의 차이점은 생성자는 리턴값이 없다. 또 생성자는 클래스명과 명칭이 동일하다.

```c++
class Human {
	private:
		int age;
	public:
		Human();
		int getAge(void);
		void plusAge(void);
		void setAge(int Age);
};

int Human::getAge(void) {
	return (age);
}

Human::Human() {
	age = 0;
}

int	main(void)
{
	Human p;
	std::cout << p.getAge() << std::endl;
	return (0);
}
```

선언과 동시에 생성자가 실행되어 멤버 변수를 초기화하는 동작 등 원하는 동작들을 수행할 수 있다. 다음 코드는 0이 출력될 것이다.

#### (생성자의) 다형성

OOP의 세 가지 특징 중 하나인 다형성(polymorphism) 이라는 개념이 있다. polymorphism의 사전적 의미는 한 집단 내에서 여러개의 형질이 구별되는 것을 의미한다. 보통 OOP에서의 다형성은 서로 다른 데이터형에 대해 동일한 형태로 인터페이스를 제공할 수 있는 능력을 의미한다.

쉽게 말하면 동일한 함수명으로 여러 종류의 인수를 받을 수 있도록 하는 것이 다형성의 능력이다.

생성자에도 다형성을 적용할 수 있다. 위 코드는 인스턴스를 생성하면 무조건 멤버변수 age는 0으로 set된다. 하지만 다른 값으로 초기화를 하고 싶을 수도 있을 것이다. 이런 경우 동일한 생성자 명칭으로 인수를 받는 형태로 만들면 된다.

```c++
class Human {
	private:
		int age;
	public:
		Human();
		Human(int Age);
		int getAge(void);
		void plusAge(void);
		void setAge(int Age);
};

int Human::getAge(void) {
	return (age);
}

Human::Human() {
	age = 0;
}

Human::Human(int Age) {
	age = Age;
}

int	main(void)
{
	Human p;
	Human p1(12);
	std::cout << p.getAge() << std::endl;
	std::cout << p1.getAge() << std::endl;
	return (0);
}
```

위 코드는 1과 12가 출력될 것이다.

#### 변수 명명

C++ 에서는 보통 카멜케이스나 파스칼케이스를 사용한다고 한다. (필수는 아니다)

#### C++의 string 클래스

기존 C에서 문자열을 char형의 배열 형태로 다루는게 복잡해서 그런지 C++에는 문자열을 간단하게 다룰 수 있는 string 클래스를 표준 라이브러리 차원에서 제공한다. 또 해당 과제에서 string 클래스를 참조하라 하였으니 string 클래스를 간략하게 공부해본다.

C++에서도 문자열 자료형을 지원하지 않기 때문에 string 클래스를 제공하며 내부에 여러 기능들을 지원하기 때문에 자료형처럼 사용 가능하다. cin, cout으로 바로 출력도 가능하며 문자열이 저장되는 공간을 알아서 관리해준다.

여러 멤버 함수 뿐만이 아니라 '+', '+=' 연산자도 오버로딩 되어있어서 직관적인 사용이 가능하다.

#### C++의 iomanip 헤더

iomanip 헤더는 cin/cout으로 입출력되는 내용에 대해 형식을 지정할 수 있도록 해 준다.

이 주제에서 필요한 설정 옵션만 살펴보자

- setw : 출력되는 내용의 width를 지정한다.

#### std::cin

cin을 사용하다 보면 여러 예외사항에 대해 체크를 할 때 버퍼가 비워지지 않아 이상하게 동작을 하는 경우가 존재한다. 혹은 숫자를 받아야 하는데 문자열을 받거나 하면 에러가 발생한다.

단순히 입력 버퍼를 아예 비워버리고 싶은데 C++에서의 입출력 관련 표준은 꽤 복잡하게 이루어져 있다. 중요한 부분이라면 중요한 부분이겠지만 C++을 이용해서 표준 입/출력에 대해 깊게 코딩할 일이 없을 것이라 판단하여 간략하게 넘어간다.

그래서 입력 버퍼를 비우기 위한 방법들을 빠르게 찾아본다.

- cin.ignore

  입력스트림의 함수로 특정 문자가 나올때까지 특정 바이트(기본값 : 1)만큼 지운다. 만약 특정 문자(기본값 : eof)에 도달하면 문자 삭제를 멈춘다. 아무런 인수 없이 사용할 경우 1개의 문자만 지운다.

  어떤 값을 얼마나 입력할지 모르고 엔터(개행)를 기준으로 입력하기에 인수는 적당히 `std::cin.ignore(INT_MAX, '\n')` 와 같이 했다.

- cin.clear

  스트림의 버퍼를 비워주는 함수가 아니라 스트림의 에러 플래그를 지워주는 함수이다. 오해하지 말자.