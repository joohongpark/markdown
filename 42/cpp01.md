# C++ 입문 #1 (C++ Module 01)

## ※ C++98 버전 기준임.

## ex00

적절한 "Pony"라는 무엇인가 동작하는 클래스를 만들고 힙 영역에 할당하는 함수와 스택 영역에 할당하는 함수를 만들라는 문제이다. pony는 조랑말이라는 뜻이므로 적절한 조랑말같은 클래스를 만들어야 한다.

### 학습해야 할 내용

- 힙영역 할당/스택영역 할당
- C++의 new 연산자와 delete 연산자
- 생성자
- 멤버 초기화 리스트

### 힙영역과 스택영역 할당의 차이

C를 코딩해본 사람이라면 전역변수를 제외하면 대부분 지역변수를 사용해서 변수나 구조체 포인터 등을 사용한다. 이런 경우 함수가 호출되면 이 지역변수들은 모두 스택에 쌓이게 된다.

프로그램이 실행되는 프로세스의 형태에서도 프로세스의 스택 영역엔 함수의 매개변수나 지역변수 등이 저장된다. 그러니까 전역/정적 변수를 사용하는 경우를 제외하고 평범하게 코딩한다면 사실상 스택 영역에 변수를 할당하여 사용하는 것이다.

따라서 어느 함수의 지역변수로 사용되면 이는 스택 영역에 할당된 것으로 보아도 되는 것이다.

힙 영역은 동적으로 할당된 변수가 저장되는 공간이다. C에서는 malloc, calloc 등 메모리 동적 할당 함수를 사용해 힙 영역에 원하는 공간만큼 할당하고 할당된 힙 메모리 주소를 리턴한다.

힙 영역은 스택 영역과 다르게 변수를 얼마나 할당해야 하는지 미리 알려주지 않고 코드 실행 도중 원하는 크기만큼 할당할 수 있다.

### new 연산자, delete 연산자

C++에서 인스턴스와 같은 것을 동적으로 할당할 때 보통 new 연산자를 사용한다. malloc과 같은 함수가 사용이 불가능한 것은 아니지만 new 연산자를 사용한다. (malloc는 함수이고 new는 C++에서 지원하는 문법이다.)

그리고 클래스로부터 인스턴스를 생성할 때 malloc 함수를 이용해서 생성하면 생성자가 호출되지 않으므로 불편하다. new 연산자는 인스턴스가 생성될 때 자동으로 생성자도 호출해 준다.

free 함수에 대응되는 연산자는 delete이다. 이것도 malloc/new 연산자의 관계와 비슷하다.

### 생성자

클래스를 힙에 할당하던 스택에 할당하던 인스턴스화 하여 사용할 것이다. 인스턴스화 하면 이전에 설명한대로 생성자라는 것이 동작하게 된다. 디폴트 생성자는 입력 인수가 없으므로 멤버 변수에 쓰레기 값이 들어있지 않도록 하는 데 의의가 있다. 디폴트 생성자는 필수가 아니다. 입력 인수가 존재하는 생성자도 만들 수 있다. C++는 오버로딩을 지원한다.

### 생성자 멤버 초기화 리스트

C++은 C에 비해 다양하게 변수에 값을 대입할 수 있다.

```c++
int i = 1;
int j(2);
int k = int(3);
```

마치 클래스에서 생성자를 통해 초기화하여 대입하는 것처럼 일관성있게 다른 모든 자료형에 대해서도 2번과 3번처럼 할당이 가능하다. (이를 Direct initialization, 직접 초기화라고 한다.) 따라서 클래스 Test의 멤버변수 int a, char b, std::string c 라는 변수를 생성자를 초기화 할 때는 다음과 같이 사용하는 것이 일반적일 것이다. (특히 자바같은 언어에선 private 멤버(변수) 에 대해 setter는 모두 다음과 같이 써야 한다.)

```c++
Test::Test(int _a, char _b, std::string _c) {
  a = _a;
  b = _b;
  c = _c;
}
```

그런데 C++에선 (생성자) 멤버 초기화 리스트를 사용해 멤버를 초기화 한다.

```c++
Test::Test(int _a, char _b, std::string _c) : a(_a), b(_b), c(_c) {
}
```

디폴트 생성자도 멤버 초기화 리스트를 사용해 초기화할 수 있다.

## ex01

주어진 코드(함수)에 대해 메모리 Leak이 발생하는 부분에 대해 보완해라.

### 학습해야 할 내용

- C++ delete 연산자

#### C++ delete 연산자

C++에서 delete 연산자를 사용하면 그 포인터 변수가 가리키고 있는 영역이 할당 해제되는 행동만을 한다. 그래서 보통 이중 free나 free된 영역에 접근을 하지 못하게 delete (C에서는 free) 처리된 포인터 변수에 NULL 값을 집어 넣기도 한다. (필수는 아니다.)

C++에선 널포인터에 대해 delete 연산자를 사용할 경우 아무런 동작도 하지 않는다. 그래서 메모리를 해제할 때 그 메모리를 가리키는 포인터에 NULL 할당을 하는 것이 권장된다.

## ex02

1. "Zombie" 클래스 만들기

   1. 멤버 변수 : type, name
   2. 멤버 함수 : announce(void)
      1. 실행시 `<name (type)> Braiiiiiiinnnssss...`

2. "ZombieEvent" 클래스 만들기

   1. 멤버 변수 : 
   2. 멤버 함수
      1. setZombieType() : 객체의 타입을 저장한다.
      2. Zombie *newZombie(std::string name) : 좀비를 만들고 선택된 타입과 네임을 저장한 후 리턴.
      3. randomChump() : 랜덤한 이름을 가진 좀비를 만들고 자체 announce를 실행한다. name pool에서 랜덤으로 뽑아오거나 진짜 랜덤하게 만들거나 알아서 (이를 위한 random 멤버함수로 만들어야 할 듯?)


나는 Zombie 클래스는 힙/스택에 생성해보고 ZombieEvent 클래스로부터 Zombie 객체를 만드는 예제를 제시해보았다.

### 학습해야 할 내용

- 랜덤 라이브러리

### 랜덤 라이브러리

C++에선 랜덤 변수를 만들기 위해 `ctime` 과 `random` 두 헤더중 하나를 추가하여 사용할 수 있다. 하지만 `random` 헤더는 C++11 이상부터 사용할 수 있으므로 `ctime` 을 사용하여야 한다. `ctime` 은 C 표준 라이브러리 헤더인 `time.h` 와 유사하다.

그래서 C에서 랜덤 변수를 생성하는 방법으로 랜덤 변수를 생성하면 된다.

## ex03

1. ex02에서 사용한 Zombie 클래스를 이용해서 ZombieHorde 클래스를 만든다.
2. ZombieHorde 클래스는 생성자에 정수 N을 받으며 생성 시 N개의 Zombie 인스턴스들을 할당하며 전부 랜덤한 이름들을 부여한다. 그러고 나서 인스턴스들의 announce 멤버함수를 실행한다.
3. ZombieHorde 클래스가 파괴될 때 내부 인스턴스들을 할당 해제해야 한다.

### 학습해야 할 내용

- 배열 클래스 동적할당 및 할당해제

## ex04

"HI THIS IS BRIAN" 이라는 문자열을 포인터와 레퍼런스를 이용해 표준 출력에 출력하는 프로그램을 만들어라.

### 학습해야 할 내용

- C++의 포인터와 레퍼런스

### C++ 레퍼런스 (참조형) 변수

C에서 호출한 함수 내에서 외부의 변수 값을 변경하거나 하려면 포인터를 사용해야 했다. 또 포인터를 사용해 다른 변수를 참조하는 식으로 사용할 때 문제가 되는 점은 특정 상황에서 참조하고 있는 포인터 변수가 NULL이 되면 세그먼트 오류가 발생한다.

예를 들어서

```c
int i = 10;
void add(int *i)
{
    *i = *i + 1;
}
```

와 같이 사용할 때 add 인수로 0(=NULL)이 들어가면 런타임 도중에 에러가 발생한다.

C++에서는 이런 예외 상황을 통제하기 위해 다른 코드에서 기존 변수를 참조할 때 편하게 사용할 수 있는 레퍼런스형 변수가 추가되었다.

```c++
int& i;
char& c;
[type]& [var];
```

위와 같이 타입명 뒤에 &를 붙이면 레퍼런스 변수가 된다.

사용예를 보자.

```c++
#include <iostream>

void test(int& i) {
	std::cout << i << std::endl;
	i = 4321;
}

int main(void) {
	int i = 1234;
	int& j = i;
	test(i);
	std::cout << i << std::endl;
	j++;
	std::cout << i << std::endl;
	return (0);
}
```

위의 main 함수 내 int형 i와 int 참조형 j가 있다. 참조형 변수는 선언 시 초기화 하여야 한다. 또 함수의 인수로 들어갈 수도 있다.

일단 위 상황에서 main 함수에서 선언된 i와 test의 인수로 입력된 i는 본질적으로 같은 메모리 위치를 가리키므로 1234를 출력한 후 i가 4321으로 변경되었으므로 main함수에서 4321을 출력한다. 또 j는 i와 같은 메모리 위치를 가리키므로 4322를 출력하게 된다.

만약 위 코드에서 test에 널포인터가 입력된다면 컴파일 자체가 되지 않는다.

## ex05

Brain이라는 이름에 어울리는 적절한 클래스를 하나 만들어라. 그리고 그건 identify() 라는 멤버함수를 가져야 한다. 이 멤버함수는 이 객체가 할당된 주소의 문자열을 반환하며 양식은 0x로 시작하는 대문자 16진수이다.

그리고 Human 클래스를 만들어야 하며 위 Brain이라는 속성을 상수로 가지고 있어야 한다. 또 이 클래스도 마찬가지로 identify() 라는 멤버함수를 가지고 있어야 하며 호출될 때 Brain 내의 identify() 멤버함수를 호출해야 한다.

Human 클래스에는 Brain 속성에 접근할 수 있는 멤버함수가 있으며 그 멤버함수를 통해 identify() 함수를 실행한 결과랑 Human 클래스의 identify() 멤버함수를 직접 실행한 결과와 같아야 한다.

### 학습해야 할 내용

- 클래스의 this
- 클래스의 상수 멤버변수
- 클래스의 상수 멤버함수
- C++98에서 숫자를 문자로 변환하는 방법 (검색어 : c++98 convert int to string)

### this

클래스로부터 여러 인스턴스들을 생성해도 복사가 되는 요소는 내부 멤버변수들이지 멤버함수가 그대로 복사되지 않는다. 그래서 인스턴스로부터 멤버함수를 실행시킬 때 언어 내부적으로 인스턴스의 주소를 멤버함수의 입력 인수로 집어넣게 된다. 이 인수의 포인터 값이 `this` 이다.

그래서 어느 인스턴스에서 함수를 실행시키던 그 인스턴스에 맞게 멤버함수를 실행시킬 수 있다.

예를 들어 다음 클래스를 보자.

```c++
#include <iostream>
#include <iomanip>

class Test {
	private:
		std::string Str;
	public:
		Test(std::string str);
		void print(void);
};

Test::Test(std::string str) : Str(str) {}

void Test::print() {
	std::cout << this << std::endl;
	std::cout << Str << std::endl;
	std::cout << this->Str << std::endl;
}


int	main(void)
{
	Test p("테스트");
	std::cout << &p << std::endl;
	p.print();
	return (0);
}
```

멤버 함수에서 멤버 변수에 접근할 때엔 그냥 멤버 변수 이름만 쓰면 되는데 실제로는 this->멤버변수와 같은 의미가 되는 것이다. 또 외부에서 인스턴스의 포인터 주소는 멤버변수 내부에서 this와 완전히 동일하다.

### 클래스의 상수 멤버변수

클래스의 상수 멤버변수가 존재할 수 있으며 상수 멤버변수의 초기화는 생성자에서 하거나 상수 멤버변수에 초기식을 지정하는 방법이 있다.

### 클래스의 상수 멤버함수

클래스의 상수 멤버함수는 해당 멤버함수가 다룰수 있는 (this 포함) 변수에 대해 값을 임의로 변경하지 않는, 변수에 대한 상수성(?)이 보장되는 함수이며 이 함수에는 함수명과 중괄호 사이에 const 키워드가 붙는다.

원래대로라면 그러한 성격을 가지고 있는 멤버함수들 (그러니까 값을 임의로 변경하지 않는 상수 멤버함수)에 const를 붙여야 한다. 붙이지 않으면 그 클래스가 상수 객체로 선언이 될 때 문제가 생길 수 있다. (이번 문제의 핵심임)

### C++98에서 int를 string으로 변환하기

C++98 이후버전에선 std::string 클래스에서 변환할수 있는 기능을 제공해 주지만 C++98 버전을 사용해야 하므로 방법을 찾아본다. 직접 itoa를 만드는것도 좋겠지만 C++ 내장 기능을 이용해보자.

C++에는 `stringstream` 이라는 클래스가 있다. 표준 입출력 대신 문자열로 표준 입출력처럼 쓰는 클래스이다.

관련 헤더 `sstream` 을 include 하고 stringstream 객체를 생성한 다음 그 객체를 cout 대신 사용하면 된다. 이후 그 객체를 string으로 변환하면 된다.

```c++
#include <iostream>
#include <sstream>

int main(void) {
	std::stringstream ss;
	ss << "테스트" << std::endl;
	std::cout << ss.str() << std::endl;
	return (0);
}
```

## ex06

- Weapon 클래스
  - string type;
  - getType() (const reference 리턴)
  - setType()
- HumanA 와 HumanB 클래스
  - Weapon 변수 보유
  - name 변수 보유
  - attack() 함수 보유
    - "NAME attacks with his WEAPON_TYPE" 출력
- 